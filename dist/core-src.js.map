{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/@turf/area/index.js","webpack:///./node_modules/@turf/boolean-point-in-polygon/index.js","webpack:///./node_modules/@turf/difference/index.js","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/meta/index.js","webpack:///./node_modules/fuse.js/dist/fuse.js","webpack:///./node_modules/martinez-polygon-clipping/dist/martinez.umd.js","webpack:///./node_modules/node-libs-browser/node_modules/punycode/punycode.js","webpack:///./node_modules/querystring-es3/decode.js","webpack:///./node_modules/querystring-es3/encode.js","webpack:///./node_modules/querystring-es3/index.js","webpack:///./node_modules/url/url.js","webpack:///./node_modules/url/util.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/adjofer/index.js","webpack:///./src/adjofer/load.js","webpack:///./src/adjofer/status.js","webpack:///./src/centro/corrections.js","webpack:///./src/centro/filters.js","webpack:///./src/centro/icons/boliche.js","webpack:///./src/centro/icons/css.js","webpack:///./src/centro/icons/images/boliche.svg","webpack:///./src/centro/icons/images/solicitud.svg","webpack:///./src/centro/icons/index.js","webpack:///./src/centro/icons/sass/chupachups.sass?a5ba","webpack:///./src/centro/icons/sass/piolin.sass?4ef7","webpack:///./src/centro/icons/solicitud.js","webpack:///./src/centro/index.js","webpack:///./src/index.js","webpack:///./src/interface/contextmenu.js","webpack:///./src/interface/images/ajax-loader.gif","webpack:///./src/interface/images/zoom-in.png","webpack:///./src/interface/images/zoom-out.png","webpack:///./src/interface/index.js","webpack:///./src/interface/loading.js","webpack:///./src/interface/popupruta.js","webpack:///./src/interface/progressbar.js","webpack:///./src/interface/sass/adjofer.sass?7576","webpack:///./src/interface/searchbar.js","webpack:///./src/localidad/icon.js","webpack:///./src/localidad/images/localidad.svg","webpack:///./src/localidad/index.js","webpack:///./src/ors/geocode.js","webpack:///./src/ors/index.js","webpack:///./src/ors/isochrones.js","webpack:///./src/ors/route.js","webpack:///./src/ors/utils.js","webpack:///./src/solicitud.js","webpack:///./src/utils/misc.js","webpack:///./src/utils/turf.js","webpack:///external \"L\"","webpack:///external {\"root\":[\"L\",\"Map\",\"ContextMenu\"],\"amd\":\"leaflet-contextmenu\",\"commonjs\":\"leaflet-contextmenu\",\"commonjs2\":\"leaflet-contextmenu\"}","webpack:///external {\"root\":[\"L\",\"Control\",\"Search\"],\"amd\":\"leaflet-search\",\"commonjs\":\"leaflet-search\",\"commonjs2\":\"leaflet-search\"}","webpack:///external {\"root\":[\"L\",\"Marker\",\"Mutable\"],\"amd\":\"leaflet.mutatismutandis\",\"commonjs\":\"leaflet.mutatismutandisx\",\"commonjs2\":\"leaflet.mutatismutandis\"}"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,sDAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,gEAAiB;AAC3C;AACA;AACA;AACA;AACA,YAAY,YAAY,QAAQ,cAAc,KAAK,mBAAmB;AACtE;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,8BAA8B;AACzC,WAAW,OAAO,YAAY;AAC9B,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ,2CAA2C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,qBAAqB;AAChC,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHa;;AAEb,+BAA+B,iFAAiF;;AAEhH,eAAe,mBAAO,CAAC,gGAA2B;AAClD,2BAA2B,mBAAO,CAAC,sDAAY;AAC/C,cAAc,mBAAO,CAAC,4DAAe;AACrC,gBAAgB,mBAAO,CAAC,gEAAiB;AACzC,WAAW,mBAAO,CAAC,sDAAY;;AAE/B;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,8BAA8B;AACzC,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC;AACxC;AACA;;AAEA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe,eAAe,cAAc;AAChE;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,WAAW,OAAO,YAAY;AAC9B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY,EAAE,cAAc;AAC1C;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY,EAAE,wBAAwB;AACpD;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,cAAc,EAAE,cAAc;AAC5C;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,iBAAiB;AAC9B;AACA,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc,EAAE,wBAAwB;AACtD;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc,iBAAiB,EAAE,cAAc;AAC/C;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,oBAAoB;AACjC;AACA,oFAAoF,eAAe;AACnG,oFAAoF,eAAe;AACnG;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB,EAAE,wBAAwB;AACzD;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB,uBAAuB,gBAAgB,wBAAwB;AACrF;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,kBAAkB;AAC/B;AACA,kDAAkD,mBAAmB;AACrE,kDAAkD,mBAAmB;AACrE,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,yBAAyB;AACtC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,oBAAoB;AACjC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,sBAAsB;AACnC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO,eAAe;AACjC,WAAW,OAAO,YAAY;AAC9B,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA,kCAAkC,6BAA6B;AAC/D,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA,kCAAkC,yBAAyB;AAC3D,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5tBa;AACb,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,4DAAe;AACvC;AACA;AACA;AACA;AACA,WAAW,6CAA6C;AACxD,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD,yBAAyB,kBAAkB;AAC3C;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB;AAChE,yBAAyB,kBAAkB;AAC3C;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,cAAc;AAC3B,YAAY,MAAM;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClNa;;AAEb,8CAA8C,cAAc;;AAE5D,cAAc,mBAAO,CAAC,4DAAe;;AAErC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,2BAA2B,aAAa;AACxC,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA,+BAA+B,sBAAsB;AACrD,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,EAAE;AACf;AACA;AACA,2BAA2B,aAAa;AACxC,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,6BAA6B,WAAW;AACxC,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,6BAA6B,WAAW;AACxC,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,2BAA2B,WAAW;AACtC,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,2BAA2B,aAAa;AACxC,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,aAAa,qBAAqB;AAClC;AACA;AACA,2BAA2B,WAAW;AACtC,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,6BAA6B,WAAW;AACxC,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;;AAEzB;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,6BAA6B,WAAW;AACxC,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB;AACA;AACA,6BAA6B,WAAW;AACxC,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,mBAAmB;AACnF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,iDAAiD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,6BAA6B,WAAW;AACxC,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAkE;AAC7E,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,kEAAkE;AAC7E,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,OAAO,YAAY;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO,uBAAuB;AACzC,WAAW,KAAK,iBAAiB;AACjC,WAAW,cAAc,eAAe;AACxC,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,OAAO,YAAY;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO,uBAAuB;AACzC,WAAW,KAAK,iBAAiB;AACjC,WAAW,cAAc,eAAe;AACxC,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA,8BAA8B,sCAAsC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3mCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAiD,oBAAoB,SAA8G,CAAC,iBAAiB,mBAAmB,SAAS,cAAc,4BAA4B,YAAY,qBAAqB,2DAA2D,uCAAuC,qCAAqC,oBAAoB,EAAE,iBAAiB,4FAA4F,eAAe,wCAAwC,SAAS,EAAE,mBAAmB,8BAA8B,qDAAqD,0BAA0B,6CAA6C,sBAAsB,6DAA6D,YAAY,eAAe,SAAS,iBAAiB,iCAAiC,iBAAiB,YAAY,UAAU,sBAAsB,mBAAmB,iDAAiD,iBAAiB,gBAAgB,sBAAsB,4FAA4F,iBAAiB,cAAc,iFAAiF,gBAAgB,aAAa,oGAAoG,KAAK,gBAAgB,YAAY,WAAW,KAAK,WAAW,+GAA+G,sCAAsC,gBAAgB,obAAob,uBAAuB,mKAAmK,eAAe,8EAA8E,uBAAuB,8OAA8O,uBAAuB,UAAU,gBAAgB,sCAAsC,sBAAsB,EAAE,+BAA+B,8DAA8D,UAAU,wDAAwD,gHAAgH,iJAAiJ,EAAE,yCAAyC,qEAAqE,uFAAuF,IAAI,sCAAsC,OAAO,sDAAsD,EAAE,+BAA+B,yHAAyH,MAAM,0BAA0B,uBAAuB,IAAI,oBAAoB,mCAAmC,EAAE,sDAAsD,EAAE,OAAO,wBAAwB,YAAY,gBAAgB,IAAI,mDAAmD,IAAI,MAAM,2BAA2B,uBAAuB,cAAc,qBAAqB,8EAA8E,SAAS,WAAW,UAAU,eAAe,qDAAqD,EAAE,sDAAsD,EAAE,OAAO,sBAAsB,EAAE,mCAAmC,iLAAiL,iCAAiC,YAAY,kBAAkB,uBAAuB,0CAA0C,kBAAkB,2FAA2F,wDAAwD,WAAW,MAAM,WAAW,gDAAgD,iBAAiB,WAAW,MAAM,8BAA8B,6JAA6J,UAAU,OAAO,uBAAuB,IAAI,aAAa,yCAAyC,cAAc,gDAAgD,wEAAwE,+DAA+D,WAAW,iBAAiB,mEAAmE,SAAS,gBAAgB,mEAAmE,EAAE,gBAAgB,oCAAoC,IAAI,oBAAoB,+CAA+C,EAAE,sDAAsD,IAAI,EAAE,wCAAwC,oCAAoC,uBAAuB,IAAI,MAAM,6CAA6C,IAAI,MAAM,qEAAqE,2CAA2C,uCAAuC,EAAE,8BAA8B,0DAA0D,EAAE,gCAAgC,SAAS,yBAAyB,SAAS,2DAA2D,8BAA8B,4BAA4B,UAAU,SAAS,UAAU,SAAS,kDAAkD,eAAe,aAAa,uBAAuB,IAAI,MAAM,WAAW,gCAAgC,OAAO,wCAAwC,sHAAsH,kDAAkD,gBAAgB,EAAE,uBAAuB,IAAI,MAAM,WAAW,qFAAqF,WAAW,YAAY,gBAAgB,IAAI,eAAe,UAAU,oBAAoB,UAAU,EAAE,4BAA4B,MAAM,0DAA0D,iCAAiC,GAAG,YAAY,iBAAiB,gBAAgB,YAAY,WAAW,KAAK,WAAW,+GAA+G,sCAAsC,gBAAgB,gSAAgS,eAAe,8EAA8E,uBAAuB,8HAA8H,4HAA4H,UAAU,gBAAgB,+BAA+B,6EAA6E,oDAAoD,2DAA2D,oDAAoD,qGAAqG,8CAA8C,wEAAwE,GAAG,iCAAiC,GAAG,YAAY,eAAe,kBAAkB,EAAE,wBAAwB,wBAAwB,4IAA4I,4BAA4B,IAAI,MAAM,WAAW,kCAAkC,OAAO,0CAA0C,iBAAiB,kBAAkB,4BAA4B,yOAAyO,IAAI,YAAY,WAAW,WAAW,yDAAyD,EAAE,kDAAkD,WAAW,yDAAyD,EAAE,iBAAiB,KAAK,oCAAoC,IAAI,MAAM,gBAAgB,IAAI,EAAE,KAAK,2DAA2D,qCAAqC,IAAI,6DAA6D,gBAAgB,YAAY,KAAK,MAAM,2BAA2B,6FAA6F,yDAAyD,OAAO,sBAAsB,qBAAqB,QAAQ,2DAA2D,UAAU,IAAI,OAAO,wDAAwD,eAAe,wBAAwB,wKAAwK,sBAAsB,eAAe,qBAAqB,6JAA6J,IAAI,MAAM,WAAW,8DAA8D,0CAA0C,eAAe,sBAAsB,YAAY,gBAAgB,IAAI,sBAAsB,YAAY,IAAI,8BAA8B,UAAU,iBAAiB,WAAW,wBAAwB,yBAAyB,MAAM,gCAAgC,wCAAwC,WAAW,uFAAuF,IAAI,iBAAiB,iBAAiB,0BAA0B,eAAe,SAAS,UAAU,GAAG,E;;;;;;;;;;;ACRx+V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,KAA4D;AAC9D,EAAE,SACiC;AACnC,CAAC,4BAA4B;;AAE7B,mCAAmC,mCAAmC;;AAEtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ,qBAAqB;;;AAGzD;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA,iCAAiC,gBAAgB;AACjD,mCAAmC,mBAAmB;AACtD,iCAAiC,oBAAoB;AACrD,YAAY,YAAY;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;;AAEA,gCAAgC,gBAAgB;AAChD,kCAAkC,mBAAmB;AACrD,gCAAgC,oBAAoB;AACpD,YAAY,aAAa;AACzB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD,yBAAyB,sBAAsB;AAC/C,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,aAAa;AAC3C,4BAA4B,eAAe;AAC3C;AACA,OAAO;AACP;AACA;AACA;;AAEA,iBAAiB;;AAEjB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,gBAAgB;;AAEpC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa,OAAO,iBAAiB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,eAAe;;AAE/B;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,iBAAiB;;AAErC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa,OAAO,gBAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,gBAAgB;;AAEhC;AACA;AACA;AACA;AACA;;;AAGA;AACA,oBAAoB,gBAAgB;AACpC,mCAAmC,mBAAmB;AACtD,UAAU,oBAAoB;AAC9B,YAAY,qBAAqB;AACjC;;;AAGA;AACA;;AAEA,YAAY,iBAAiB,YAAY,EAAE;AAC3C;AACA;;;AAGA;AACA;;AAEA,YAAY,kBAAkB,aAAa,EAAE;AAC7C;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,wCAAwC,aAAa;AACrD,cAAc,YAAY;AAC1B;AACA,KAAK;AACL;AACA;AACA,mCAAmC,aAAa;AAChD,cAAc,YAAY;AAC1B;AACA;;AAEA,SAAS;;AAET,oCAAoC,gBAAgB;AACpD,sCAAsC,aAAa;AACnD,oCAAoC,WAAW;;AAE/C;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC,yBAAyB,YAAY;AACrC,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,yBAAyB,kBAAkB;AAC3C,yBAAyB,mBAAmB;AAC5C;;AAEA;AACA;;;AAGA;AACA;;AAEA,aAAa,cAAc;;AAE3B;;AAEA,kBAAkB,0BAA0B;AAC5C,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,aAAa,cAAc;;AAE3B;;AAEA,kBAAkB,0BAA0B;AAC5C,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;;AAErB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,YAAY,gBAAgB;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,qBAAqB;AACrB;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4BAA4B;AACzE,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,KAAK;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iCAAiC;AACnF,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,gBAAgB;AAC5B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,OAAO,aAAa;AAC7B;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB,YAAY,SAAS;AACrB,YAAY,GAAG;AACf,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,eAAe,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS,OAAO,aAAa;AAC7B;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS,OAAO,aAAa;AAC7B;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,SAAS,OAAO,aAAa;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB,YAAY,QAAQ;AACpB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,iDAAiD;AAC5E;AACA,kBAAkB,gDAAgD;AAClE;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,iBAAiB;AAChC,aAAa,aAAa;AAC1B;;;AAGA;AACA;AACA,eAAe,iBAAiB;AAChC,aAAa,aAAa;AAC1B;;AAEA,qDAAqD,4BAA4B;AACjF,6CAA6C,mBAAmB;;;AAGhE;AACA;AACA,YAAY,WAAW;AACvB,YAAY,cAAc;;AAE1B,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA;AACA,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,wBAAwB,QAAQ;;AAEhC;AACA;AACA;;AAEA;AACA,UAAU,KAAK,EAAE;AACjB,UAAU,KAAK,EAAE;AACjB,mBAAmB,OAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,YAAY,eAAe;AAC3B,cAAc;AACd;AACA;AACA;AACA;;;AAGA;AACA,cAAc;AACd;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,UAAU;AAClC,wBAAwB,WAAW;;AAEnC;AACA;AACA,0BAA0B,+BAA+B;;AAEzD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO,yBAAyB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,eAAe;AAC7B,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wDAAwD,aAAa;;AAErE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU,EAAE;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,cAAc,WAAW;AACzB,cAAc;AACd;AACA;AACA,sBAAsB,UAAU;;AAEhC;AACA;AACA;;AAEA;AACA,yCAAyC,mDAAmD;;AAE5F;AACA,0CAA0C,6CAA6C;;AAEvF;AACA;AACA,0CAA0C,wCAAwC;;AAElF;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA,kCAAkC;AAClC,iDAAiD,UAAU;AAC3D,cAAc,+CAA+C;AAC7D;AACA,KAAK,OAAO;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B,6BAA6B;AAC1D,6BAA6B,aAAa;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E,qCAAqC,iBAAiB;;AAEtD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,+BAA+B,6BAA6B;AAC5D,+BAA+B,aAAa;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,mBAAmB;AACjC,cAAc;AACd;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,cAAc,OAAO;AACrB,cAAc,mBAAmB;AACjC,cAAc,QAAQ;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,cAAc,mBAAmB;AACjC,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD,yBAAyB,UAAU;AACnC;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC,qCAAqC;;AAE9E;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ,OAAO,iBAAiB;AAC9E;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iDAAiD;;AAEjD,oCAAoC,QAAQ;AAC5C;AACA,yCAAyC,QAAQ;AACjD;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA,yCAAyC,QAAQ;AACjD;AACA,uCAAuC,wBAAwB;AAC/D,6BAA6B,aAAa;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;;AAE9D,CAAC;AACD;;;;;;;;;;;;ACnrDA;AACA,CAAC;;AAED;AACA,mBAAmB,KAA0B;AAC7C;AACA,kBAAkB,KAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAEU;AACZ;AACA,EAAE,mCAAmB;AACrB;AACA,GAAG;AAAA,oGAAC;AACJ,EAAE,MAAM,EAaN;;AAEF,CAAC;;;;;;;;;;;;;;ACphBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFa;;AAEb,iCAAiC,mBAAO,CAAC,0DAAU;AACnD,qCAAqC,mBAAO,CAAC,0DAAU;;;;;;;;;;;;;ACHvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,oFAAU;AACjC,WAAW,mBAAO,CAAC,0CAAQ;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C,KAAK;AAChD,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,mBAAO,CAAC,4DAAa;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3tBa;;AAEb;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACfA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACsC;AACU;AAChB;AACc;AACC;AACT;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+DAA+D,8DAAa;;AAE5E,MAAM,gDAAO;AACb,MAAM,0DAAa;AACnB;AACA,MAAM,8DAAS;AACf,2BAA2B,qDAAS;AACpC;AACA,MAAM,gDAAY,YAAY;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB,2BAA2B;;AAElD,OAAO;AACP,mDAAmD,eAAe;AAClE;AACA;;AAEA;AACA,6BAA6B;AAC7B,oCAAoC,aAAa;AACjD;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA,aAAa,4DAAe;AAC5B,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,oCAAoC,OAAO;;AAE3C;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA,oBAAoB,4DAAe;AACnC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA;AACA;AACA,sBAAsB;AACtB,mBAAmB;;;AAGnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;AACA,sBAAsB;AACtB,mBAAmB;AACnB;;AAEA;AACA,gBAAgB;AAChB;AACA,2DAA2D,kEAAiB;AAC5E;AACA,aAAa;;AAEb;AACA;AACA;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB,IAAI,sBAAsB;AACtE,UAAU;AACV;AACA,wCAAwC,kEAAiB;AACzD;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ,cAAc,8CAAU;AACxB,cAAc,8CAAU;AACxB,gBAAgB,kEAAiB;AACjC,CAAC;;AAEc;AACf,8CAA8C,kDAAc,eAAe;AAC3E;AACA,CAAC;;;;;;;;;;;;;;AC1RD;AAAA;AAAA;AAAA;AAAiD;AACD;AACtB;;AAE1B;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,kEAAiB;;AAElE;AACA;;AAEA;AACA,mCAAmC,EAAE,yBAAyB,EAAE,EAAE,EAAE,EAAE,EAAE;AACxE,oCAAoC;AACpC;AACA,cAAc;AACd;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB,2CAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,gEAAe,aAAa;;AAE3E;AACA,GAAG,gEAAc;AACjB,GAAG,gEAAc;AACjB;;AAEA,GAAG,gEAAc,yCAAyC;;AAE1D;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAiB;AAC/C;AACA;AACA;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA,qBAAqB,+CAAG;AACxB,0CAA0C,qCAAqC;;AAE/E,MAAM,gEAAc;;AAEpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4C;AACA,mDAAmD,oCAAoC;AACvF;AACA,mBAAmB;AACnB;AACA;AACA;AACA,6CAA6C,oCAAoC;AACjF;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA,mBAAmB;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4C;AACA,+CAA+C,+BAA+B;AAC9E;AACA,mBAAmB;AACnB;AACA;AACA;AACA,yCAAyC,+BAA+B;AACxE;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,wCAAwC,kEAAiB;AACzD;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS,gEAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAiB;AACzD;AACA,UAAU;AACV,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,kEAAiB;AACrD;AACA;AACA;AACA;AACA,oCAAoC,kEAAiB;AACrD;AACA;AACA;AACA,wCAAwC,kEAAiB;AACzD;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,kEAAiB;AAC/C;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,OAAO;AACP;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;;AC7QpB;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,gC;AACA,iCAAiC,YAAY;AAC7C,IAAI;;AAEJ,gC;AACA,iCAAiC,YAAY;AAC7C,IAAI;;AAEJ;AACA;AACA;AACA,2DAA2D,YAAY;AACvE,IAAI;;AAEJ;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C,IAAI;;AAEJ;AACA;AACA;AACA,2DAA2D,YAAY;AACvE,IAAI;;AAEJ;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E,IAAI;;AAEJ;AACA;AACA;AACA,2DAA2D,YAAY;AACvE,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,OAAO,GAAG,OAAO,EAAE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,OAAO,GAAG,OAAO,EAAE;AACjE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA,iCAAiC;AACjC,iCAAiC,aAAa,OAAO,EAAE;AACvD,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa,OAAO,EAAE;AACvD,IAAI;;AAEJ;AACA;AACA,iCAAiC,YAAY;AAC7C,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC,WAAW;AACnD;;AAEA;AACA,kCAAkC,uCAAuC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;;AAEiC;;;;;;;;;;;;;ACjOjC;AAAA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACe;AACf;;AAEA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,uDAAuD;AACvD,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uCAAuC;AACvC,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,YAAY;AAC3C;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,CAAC;;;;;;;;;;;;;AClTD;AAAA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACe;AACf;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,uBAAuB,mCAAmC;AAC1D;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC;;;;;;;;;;;;;;ACjFD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6D;AACtB;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,yBAAyB;AACxC,wBAAwB,iEAAO,CAAC,kEAAQ;AACxC;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,kBAAkB,kEAAQ;AAC1B,wBAAwB,iEAAO;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,YAAY,iEAAO,CAAC,0DAAG;;AAES;;;;;;;;;;;;;;ACpIhC;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEkC;;;;;;;;;;;;;ACdlC,qCAAqC,w+H;;;;;;;;;;;ACArC,qCAAqC,g0B;;;;;;;;;;;;ACArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACgC;AACQ;AACI;AACF;AACd;AACI;;AAEjB;AACf;AACA;AACA;AACA;AACA,YAAY,4CAAQ;AACpB,iBAAiB,iDAAa;AAC9B,eAAe,+CAAW;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA,YAAY,4CAAQ;AACpB,iBAAiB,iDAAa;AAC9B,eAAe,+CAAW;AAC1B,IAAI;AACJ;AACA;AACA;AACA,WAAW,iDAAa;AACxB,iBAAiB,uDAAmB;AACpC,eAAe,qDAAiB;AAChC,IAAI;AACJ;AACA;AACA;AACA,WAAW,+CAAW;AACtB,iBAAiB,qDAAiB;AAClC,eAAe,mDAAe;AAC9B,IAAI;AACJ,CAAC;;;;;;;;;;;;;ACzCD,uC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACD;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,iEAAO,CAAC,4DAAG;;AAES;;;;;;;;;;;;;;ACjChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AACR;AACD;;AAExC;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,iBAAiB,2CAAgB;AACjC;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;;AAEJ,GAAG,uDAAiB;AACpB,GAAG,mDAAa;AAChB;;AAEyB;;;;;;;;;;;;;;ACxCzB;AAAA;AAA4C;AAC7B,wHAAU,EAAC;;;;;;;;;;;;;ACD1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACA;AACE;;AAE5C;AACA;AACA,4CAAiB;;AAEjB;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kBAAkB,iEAAO,CAAC,0DAAM;AAChC;AACA,UAAU;AACV;AACA;AACA,kBAAkB,iEAAO,CAAC,2DAAO;AACjC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,SAAS,WAAW;AACpB;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;ACnI5B,iCAAiC,oiB;;;;;;;;;;;ACAjC,iCAAiC,4uG;;;;;;;;;;;ACAjC,iCAAiC,4tG;;;;;;;;;;;;ACAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACd;AACI;AACI;AACJ;;AAET;;AAEmC;;;;;;;;;;;;;ACRhE;AAAA;AAAA;AAAA;AAA0C;AACI;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAO,CAAC,8DAAM;AAC5C;AACA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;;ACpBvB;AAAA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,yBAAyB,EAAE,IAAI,EAAE;AACjC;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;;AAEzD;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,OAAO;;AAEtD;;AAEA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;ACxCzB;AAAA,yCAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACPD,uC;;;;;;;;;;;;ACAA;AAAA;AACA;AACA;AACA,2BAA2B,+BAA+B,IAAI,SAAS;;AAEvE,uBAAuB,2CAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,iBAAiB;AACjB,OAAO;AACP;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;;AC5DzB;AAAA;AAAA;AAAA;AAA0C;AACD;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA,QAAQ,iEAAO,CAAC,4DAAG;AACnB;AACA;AACA,CAAC,CAAC,EAAC;;;;;;;;;;;;;ACnCH,qCAAqC,gnB;;;;;;;;;;;;ACArC;AAAA;AAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,2CAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,yDAAyD;AACzD,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,iBAAiB,gDAAK;;AAEtB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,UAAU;AACV;AACA,OAAO;AACP,IAAI;AACJ;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;;ACnHtB;AAAA;AAA+C;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,qBAAqB;AACtD;;AAEA,GAAG,uEAAa;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC;AACA,iCAAiC,WAAW;AAC5C;AACA,YAAY;AACZ;AACA,iCAAiC,6CAA6C;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;;ACxFvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACJ;AACP;AACL;AACL;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B;AAC9B;AACA;AACA,8DAA8D,gEAAO;AACrE,uCAAuC,kEAAS;AAChD,IAAI;;AAEJ,wBAAwB,sDAAS;AACjC;AACA;AACA;;AAEA,mBAAmB,iDAAI;AACvB,sBAAsB,mDAAO;;AAE7B;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;AC3CnB;AAAA;AAAA;AAAmE;AACnB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA,4BAA4B,iEAAO,CAAC,kEAAQ;AAC5C;AACA,mBAAmB;AACnB;AACA;AACA,OAAO;AACP;AACA,IAAI;;AAEJ,GAAG,uEAAa,6BAA6B;AAC7C;AACA;AACA,GAAG,uEAAa,gBAAgB,0BAA0B;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B;AAC5B;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,4DAAU;AACnB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,oCAAoC;AACtE;;AAEA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV,2B;AACA,YAAY,0DAAQ;AACpB;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,iCAAiC;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,+BAA+B;AACpF;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA,kDAAkD,iCAAiC;AACnF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;;AAEA,eAAe,0BAA0B;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;;AClQzB;AAAA;AAAA;AAAgD;AACV;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,qBAAqB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,GAAG,uEAAa,6BAA6B,YAAY;AACzD,GAAG,uEAAa,gBAAgB;AAChC;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS,4DAAU;AACnB,SAAS,4DAAU;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+CAA+C,6BAA6B;AAC5E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;;ACzIpB;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;ACZ7B;AAAA;AAAA;AACA;;AAEkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA,2BAA2B,2CAAgB;;AAE3C;AACA;;AAEA;AACA;AACA,gCAAgC,cAAc;AAC9C,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,+BAA+B,iEAAe;AAC9C,OAAO;AACP;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA,YAAY,iEAAe;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA,IAAI;AACJ,uCAAuC,kBAAkB;AACzD;AACA;;;AAGA;AACA;AACA,sBAAsB,UAAU;AAChC;;AAEA,2BAA2B,2CAAgB;AAC3C;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,2CAAgB;;AAE7C;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;;AC/RzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,yBAAyB,EAAE;AAClD;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA,wBAAwB,2CAAgB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO,MAAM,OAAO;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,0CAAG;AACb;;;AAGoE;;;;;;;;;;;;;;ACxKpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEmD;AACyB;;AAEjC;;;;;;;;;;;;ACL3C,qD;;;;;;;;;;;ACAA,iE;;;;;;;;;;;ACAA,4D;;;;;;;;;;;ACAA,qE","file":"core-src.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"L\"), require(\"leaflet-contextmenu\"), require(\"leaflet-search\"), require(\"leaflet.mutatismutandis\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"lobaton\", [\"L\", \"leaflet-contextmenu\", \"leaflet-search\", \"leaflet.mutatismutandis\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lobaton\"] = factory(require(\"L\"), require(\"leaflet-contextmenu\"), require(\"leaflet-search\"), require(\"leaflet.mutatismutandisx\"));\n\telse\n\t\troot[\"lobaton\"] = factory(root[\"L\"], root[\"L\"][\"Map\"][\"ContextMenu\"], root[\"L\"][\"Control\"][\"Search\"], root[\"L\"][\"Marker\"][\"Mutable\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_leaflet__, __WEBPACK_EXTERNAL_MODULE_leaflet_contextmenu__, __WEBPACK_EXTERNAL_MODULE_leaflet_search__, __WEBPACK_EXTERNAL_MODULE_leaflet_mutatismutandis__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar martinez = require('martinez-polygon-clipping');\nvar area = _interopDefault(require('@turf/area'));\nvar helpers = require('@turf/helpers');\nvar invariant = require('@turf/invariant');\nvar meta = require('@turf/meta');\n\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = invariant.getGeom(polygon1);\r\n    var geom2 = invariant.getGeom(polygon2);\r\n    var properties = polygon1.properties || {};\r\n\r\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\r\n    geom1 = removeEmptyPolygon(geom1);\r\n    geom2 = removeEmptyPolygon(geom2);\r\n    if (!geom1) return null;\r\n    if (!geom2) return helpers.feature(geom1, properties);\r\n\r\n    var differenced = martinez.diff(geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    if (differenced.length === 1) return helpers.polygon(differenced[0], properties);\r\n    return helpers.multiPolygon(differenced, properties);\r\n}\r\n\r\n/**\r\n * Detect Empty Polygon\r\n *\r\n * @private\r\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\r\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\r\n */\r\nfunction removeEmptyPolygon(geom) {\r\n    switch (geom.type) {\r\n    case 'Polygon':\r\n        if (area(geom) > 1) return geom;\r\n        return null;\r\n    case 'MultiPolygon':\r\n        var coordinates = [];\r\n        meta.flattenEach(geom, function (feature) {\r\n            if (area(feature) > 1) coordinates.push(feature.geometry.coordinates);\r\n        });\r\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\r\n    }\r\n}\n\nmodule.exports = difference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","/*!\n * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"Fuse\",[],t):\"object\"==typeof exports?exports.Fuse=t():e.Fuse=t()}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):\"[object Array]\"===Object.prototype.toString.call(e)}},function(e,t,n){function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t)}var t,n,c;return t=e,(n=[{key:\"setCollection\",value:function(e){return this.list=e,e}},{key:\"search\",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\\nSearch pattern: \"'.concat(e,'\"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&\"number\"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:\"_prepareSearchers\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",t=[];if(this.options.tokenize)for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1)t.push(new i(n[r],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:\"_search\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if(\"string\"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1)this._analyze({key:\"\",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});return{weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1)for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if(\"string\"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1)throw new Error(\"Key weight has to be > 0 and <= 1\");d=d.name}else s[d]={weight:1};this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t})}return{weights:s,results:o}}},{key:\"_analyze\",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if(\"string\"==typeof i){this._log(\"\\nKey: \".concat(\"\"===n?\"-\":n));var S=f.search(i);if(this._log('Full text: \"'.concat(i,'\", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\\nPattern: \"'.concat(_.pattern,'\"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: \"'.concat(A,'\", score: ').concat(I[A]))}L&&(k+=1)}m=b[0];for(var O=b.length,j=1;j<O;j+=1)m+=b[j];m/=O,this._log(\"Token score average:\",m)}var P=S.score;m>-1&&(P=(P+m)/2),this._log(\"Score average:\",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log(\"\\nCheck Matches: \".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]))}}else if(s(i))for(var z=0,E=i.length;z<E;z+=1)this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f})}}},{key:\"_computeScore\",value:function(e,t){this._log(\"\\n\\nComputing score:\\n\");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l)}t[n].score=1===s?a:s,this._log(t[n])}}},{key:\"_sort\",value:function(e){this._log(\"\\n\\nSorting....\"),e.sort(this.options.sortFn)}},{key:\"_format\",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log(\"\\n\\nOutput:\\n\\n\",JSON.stringify(e,function(e,t){if(\"object\"===r(t)&&null!==t){if(-1!==n.indexOf(t))return;n.push(t)}return t})),n=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty(\"arrayIndex\")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:\"_log\",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,n),c&&o(t,c),e}();e.exports=c},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,n,s;return t=e,(n=[{key:\"search\",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n)return o(e,this.pattern,r);var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),s&&r(t,s),e}();e.exports=s},function(e,t){var n=/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,\"\\\\$&\").replace(r,\"|\")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1)x[b]=0;if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m)}}k=-1;for(var L=[],w=1,A=S+y,C=1<<S-1,I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O)}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g)break;P=Math.max(1,2*g-k)}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m)break;L=T}return{isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}}},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1)t[e.charAt(r)]=0;for(var o=0;o<n;o+=1)t[e.charAt(o)]|=1<<n-o-1;return t}},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf(\".\"),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c)if(s||\"string\"!=typeof c&&\"number\"!=typeof c)if(r(c))for(var h=0,l=c.length;h<l;h+=1)e(c[h],s,o);else s&&e(c,s,o);else o.push(c.toString())}else o.push(t);return o}(e,t,[])}}])});","/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.martinez = {})));\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n    if (newPos > length - 1) { return pos - 1; }\n    var p  = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point;\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * @name MapAdjOfer\n * @class\n * @hideconstructor\n * @classdesc Implementa un mapa que muestra la adjudicación de vacantes provisionales\n * y la oferta educativa de los centros públicos dependientes de la Junta de Andalucía.\n *\n * @param {String} id  Identificador del elemento HTML\n * donde se incrustará el mapa.\n * @param {Obj} opts Opciones de configuración.\n * @param {String} opts.path Ruta relativa desde el directorio en que\n * se encuentra la página web al directorio ``dist``.\n * @param {Boolean} opts.light Si ``true``, define el comportamiento del evento\n * *click* como \"seleccionar el centro pulsado\" y el evento *contextmenu* muestra\n * un menú contextual que permite generar crear rutas e isocronas. Esto libera de\n * tener que realizar en la interfaz la definición de cómo seleccionar centro y cómo\n * ordenar que se creen rutas e isocronas.\n * @param {String} opts.ors  La clave para el uso de los servios de OpenRouteService.\n * @param {Function} opts.chunkProgress   Función que se ejecuta periódicamente\n * si se demora demasiado la creación de las isoronas.\n */\nimport * as status from \"./status.js\";\nimport * as iface from \"app/interface/index.js\";\nimport loadMap from \"./load.js\";\nimport * as centro from \"app/centro/index.js\";\nimport createLoc from \"app/localidad/index.js\";\nimport Solicitud from \"app/solicitud\";\n\nconst MapAdjOfer = L.Evented.extend({\n   /** @lends MapAdjOfer.prototype */\n\n   options: {\n      id: \"map\",\n      center: [37.45, -4.5],\n      loading: true,    // Presenta un gif que ameniza la carga.\n      zoom: 8,\n      centeredZoom: 12,\n      unclusterZoom: 14,\n      autostatus: true, // Aplica el status inicial directamente.\n      light: true,      // Issue #41\n      search: true,     // Issue #51\n      ors: false,       // Issue #42\n      icon: \"boliche\"   // Estilo con que se definen las nuevas marcas.\n   },\n\n   statics: {\n   },\n\n   initialize: function(options) {\n      L.Util.setOptions(this, options);\n\n      let center = this.options.center,\n          zoom   = this.options.zoom;\n\n      delete this.options.center;\n      delete this.options.zoom;\n\n      if(this.options.loading === true) this.options.loading = iface.loading;\n\n      loadMap.call(this);\n      centro.create.call(this);\n      // Issue #79\n      createLoc.call(this);\n      this.solicitud = new Solicitud(this);\n      // Fin issue #79\n      status.build.call(this);  // Issue #62\n\n      new Promise(resolve => {\n         // Si se proporcionó centro, no se calcula la posición.\n         if(!options.center && navigator.geolocation.getCurrentPosition) {\n            navigator.geolocation.getCurrentPosition(pos => {\n               const coords = pos.coords;\n               resolve({\n                  zoom: this.options.centeredZoom,\n                  center: [coords.latitude, coords.longitude]\n               });\n            }, function (err) {\n               console.warn(\"No es posible establecer la ubicación del dispositivo\");\n               resolve({\n                  zoom: zoom,\n                  center: center\n               });\n            }, {\n               timeout: 5000,\n               maximumAge: 1800000\n            });\n         }\n         else resolve({zoom: zoom, center: center});\n\n      }).then(opts => {\n         this.map.setView(opts.center, opts.zoom, {animate: false});\n         this.tileLayer.addTo(this.map);\n         this.cluster.addTo(this.map);\n\n         if(options.autostatus && options.status) {\n            this.setStatus();  // Issue #57\n            this.fire(\"statusset\", {status: true});\n         }\n      });\n   },\n\n   /**\n    * Devuelve la clase de icono cuyo nombre es el estilo suuministrado.\n    * @param {String} estilo  Nombre del estilo.\n    * @returns {L.DivIcon}\n    */\n   getIcon: function(estilo) {\n      return centro.catalogo[estilo] || null;\n   },\n\n   /**\n    * Cambia el estilo de icono de todos las marcas de centro existentes.\n    * En cambio, si la pretensión fuera empezar a dibujar marcas con\n    * distinto estilo de icono, habría que hacer:\n    *\n    * @example\n    *\n    * mapadjofer.options.icon = \"otro_estilo\";\n    *\n    * @param {String} estilo     El estilo deseado para el icono.\n    */\n   setIcon: function(estilo) {\n      const Icono = this.getIcon(estilo);\n      if(!Icono) throw new Error(`${estilo}: Estilo de icono desconocido`);\n\n      Icono.onready(() => this.Centro.store.forEach(m => m.setIcon(new Icono())));\n      this.options.icon = estilo;\n\n      return this;\n   },\n\n   /**\n    * Agregar centros al mapa.\n    *\n    * @param {String|Object} datos  Datos en formato GeoJSON o URL donde conseguirlos.\n    */\n   agregarCentros: function(datos) {\n      const Icono = centro.catalogo[this.options.icon];\n      Icono.onready(() => {\n         if(typeof datos === \"string\") {  // Es una URL.\n            if(this.options.loading) this.options.loading();\n            L.utils.load({\n               url: datos,\n               callback: xhr => {\n                  const datos = JSON.parse(xhr.responseText);\n                  if(this.options.loading) this.options.loading();\n                  this.agregarCentros(datos);\n               }\n            });\n         }\n         else {\n            this.general = datos.features[0].properties;\n            // Capa intermedia capaz de leer objetos GeoJSON.\n            const layer = L.geoJSON(datos, {\n               pointToLayer: (f, p) => {\n                  const centro = new this.Centro(p, {\n                     icon: new Icono(),\n                     title: f.properties.id.nom\n                  });\n\n                  // Issue #33, #79\n                  centro.on(\"dataset\", e => {\n                     // Para cada centro que creemos hay que añadir a los datos\n                     // la propiedad que indica si la marca está o no seleccionada.\n                     e.target.changeData({sel: false, peticion: 0});\n                     Object.defineProperty(e.target.getData(), \"codigo\", {\n                        get: function() {\n                           return this.id.cod.toString().padStart(8, \"0\") + \"C\";\n                        }\n                     });\n                  });\n\n\n                  // Issue #41\n                  if(this.options.light) centro.once(\"dataset\", e => {\n                     e.target.on(\"click\", e => {\n                        switch(this.mode) {\n                           case \"normal\":\n                              this.seleccionado = this.seleccionado === e.target?null:e.target\n                              break;\n                           case \"solicitud\":\n                              this.fire(\"requestclick\", {marker: e.target});\n                              break;\n                        }\n                     });\n                  });\n                  // Fin issue #33, #41, #79\n\n                  return centro;\n               },\n               onEachFeature: (f, l) => {\n                  if(this.options.light) l.bindContextMenu(iface.contextMenu.centro.call(this, l));\n               }\n            });\n\n            this.cluster.addLayer(layer);\n            this.fire(\"dataloaded\");\n         }\n      });\n   },\n\n   /**\n    * Calcula la dirección postal del origen\n    */\n   calcularOrigen: function() {\n      if(!this.origen) return;\n      this.geoCodificar(this.origen.getLatLng());\n      this.once(\"addressset\", e => {\n         if(typeof this.direccion === \"string\") this.origen.postal = this.direccion;\n      });\n      // Deshabilitamos inmediatamente en el menú contextual\n      // la entrada correspondiente a geolocalizar el origen.\n      if(this.options.light) {\n         this.origen.unbindContextMenu();\n         this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n      }\n   },\n\n   /**\n    * Establece el origen de los viajes.\n    *\n    * @param {L.LatLng} latlng  Coordenadas en las que fijarlo.\n    */\n   setOrigen: function(latlng) {\n      if(latlng) {\n         this.origen = new L.Marker(latlng, {\n            title: `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`\n         });\n         if(this.options.light) {\n            this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n         }\n      }\n      else this.origen = null;\n   },\n\n   /**\n    * Establece las isocronas referidas a un origen\n    * @param {?L.LatLng|L.Marker} o Referencia para la isocronas. Si no ser\n    * proporciona se entenderá que es el origen de coordenadas.\n    */\n   setIsocronas: function(o) {\n      if(o && o.getLatLng) o = o.getLanLng();\n      if(o === true) o = undefined;\n      this.isocronas = o;\n      if(o && this.options.light && this.origen) {\n         this.origen.unbindContextMenu();\n         this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n      }\n   },\n\n   /**\n    * Devuelve las capas de las áreas de las isocronas dibujadas en el mapa.\n    *\n    * @returns {Array}\n    */\n   getIsocronas: function(maciza) {\n      return this.ors.isocronas.get(maciza);\n   },\n\n   /**\n    * Establece la ruta entre el origen y un centro\n    */\n   setRuta: function(centro) {\n      this.ruta = centro;\n      if(centro && this.options.light && this.origen) {\n         this.origen.unbindContextMenu();\n         this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n      }\n   },\n\n   geoCodificar: function(query) {\n      this.direccion = query\n   },\n\n   getStatus: status.get,\n   setStatus: status.set,\n   progressBar: iface.progressBar\n});\n\nexport default function(opts) {\n   if(opts.status) opts = Object.assign(opts, status.getOpts(opts.status));  // Issue #62\n   return new MapAdjOfer(opts);\n}\n","import {crearAttrEvent} from \"app/utils/misc.js\";\nimport * as iface from \"app/interface/index.js\";\nimport ORS from \"app/ors\";\n\n/**\n * Carga el mapa y crea la capa de cluster donde se agregan los centros.\n * @this {MapAdjOfer.prototype} El objeto que implemnta el mapa\n * @private\n */\nfunction load() {\n\n   const options = {},\n         nooptions = [\"light\", \"ors\", \"id\", \"search\", \"icon\",\n                      \"unclusterZoom\", \"centeredZoom\", \"loading\"];\n\n   for(const name in this.options) {\n      if(nooptions.indexOf(name) !== -1) continue\n      options[name] = this.options[name];\n   }\n\n   if(this.options.light) Object.assign(options, iface.contextMenu.map.call(this));\n\n   this.map = L.map(this.options.id, options);\n   this.map.zoomControl.setPosition('bottomright');\n\n   Object.defineProperty(this, \"tileLayer\", {\n      value: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n                maxZoom: 18\n             }),\n      enumerable: false,\n      configurable: false\n   });\n\n   /**\n    * Capa donde se agregan las marcas\n    * @memberof MapaAdjOfer.prototype\n    * @type {L.MarkerClusterGroup}\n    */\n   this.cluster = new L.MarkerClusterGroup({\n      showCoverageOnHover: false,\n      // Al llegar a este nivel de zoom se ven todas las marcas.\n      disableClusteringAtZoom: this.options.unclusterZoom,\n      spiderfyOnMaxZoom: false,\n      iconCreateFunction: L.utils.noFilteredIconCluster,\n   });\n\n   // Como clearLayers, pero no se carga las localidades.\n   this.cluster.clearCentros = () => {\n      for(const marker of this.cluster.getLayers()) {\n         if(marker instanceof this.Centro) this.cluster.removeLayer(marker);\n      }\n   }\n\n   if(this.options.search) this.map.addControl(iface.searchBar.call(this));  // Issue #51\n\n   // Issue #27\n   crearAttrEvent.call(this, \"origen\", \"originset\");\n   crearAttrEvent.call(this, \"seleccionado\", \"markerselect\");\n   // Fin issue #27\n\n   crearAttrEvent.call(this, \"mode\", \"modeset\", \"normal\"); // Issue #79\n\n   // Aplicación de issue #33: Cambiamos la marca\n   // al seleccionarla o deseleccionarla.\n   this.on(\"markerselect\", function(e) {\n      if(e.oldval) {\n         e.oldval.changeData({sel: false});\n         e.oldval.refresh();\n      }\n      if(e.newval) {\n         e.newval.changeData({sel: true});\n         e.newval.refresh();\n      }\n   });\n\n   // Al seleccionar/deseleccionar, hay que cambiar los\n   // menús contextuales de las marcas implicadas y\n   // el del origen (su entrada sobre rutas).\n   this.on(\"markerselect\", e => {\n      if(!this.options.light) return;\n      for(const c of [e.oldval, e.newval]) {\n         if(c) {\n            c.unbindContextMenu();\n            c.bindContextMenu(iface.contextMenu.centro.call(this, c));\n         }\n      }\n      if(this.origen) {\n         this.origen.unbindContextMenu();\n         this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n      }\n   });\n\n   // Fijar un origen, implica crear una marca sobre\n   // el mapa y destruir la antigua.\n   this.on(\"originset\", e => {\n      if(e.oldval) e.oldval.removeFrom(this.map);\n      if(e.newval) e.newval.addTo(this.map);\n   });\n\n   if(this.options.ors) {\n      /**\n       * Objecto de acceso a los servicios de OpenRouteService.\n       * @memberof {MapAdjOfer.prototype}\n       * @type {ORS}\n       */\n      this.ors = new ORS(this);\n      Object.defineProperty(this, \"ors\", {writable: false, configurable: false});\n\n      crearAttrEvent.call(this, \"contador\", \"counteradd\", 0);\n\n      Object.defineProperties(this, {\n         /** @lends MapAdjOfer.prototype */\n         \"isocronas\": {\n            get: function() {\n               return this.ors.isocronas.areas;\n            },\n            set: function(value) {\n               const old = this.isocronas;\n               if(value || value === undefined) {\n                  this.ors.isocronas.create(value).then((response) => {\n                     if(response || response === undefined) this.contador++;\n                     if(response !== null) { \n                        this.fire(\"isochroneset\", {oldval: old, newval: this.isocronas});\n                     }\n                  });\n               }\n               else {\n                  this.ors.isocronas.remove();\n                  this.fire(\"isochroneset\", {oldval: old, newval: this.isocronas});\n               }\n            },\n            enumerable: true,\n            configurable: false\n         },\n         // Issue #46\n         \"direccion\": {\n            get: function() {\n               return this.ors.geocode.value;\n            },\n            set: function(value) {  // Cadena con la dirección o coordenadas.\n               const old = this.ors.geocode.value;\n               if(value) {\n                  this.ors.geocode.query(value).then((response) => {\n                     if(response !== null) {\n                        this.contador++;\n                        this.fire(\"addressset\", {oldval: old, newval: value});\n                     }\n                  });\n               }\n               else console.warn(\"No tiene sentido calcular con valor nulo una dirección\");\n            },\n            enumerable: true,\n            configurable: false\n         },\n         // Fin issue #46\n         // Issue #47\n         \"ruta\": {\n            get: function() {\n               return this.ors.ruta.value;\n            },\n            set: function(destino) {\n               const old = this.ruta;\n               if(destino) {\n                  this.ors.ruta.create(destino).then((response) => {\n                     if(response || response === undefined) this.contador++;\n                     if(response !== null) { \n                        this.fire(\"routeset\", {oldval: old, newval: this.ruta});\n                     }\n                  });\n               }\n               else {\n                  this.ors.ruta.remove();\n                  this.fire(\"routeset\", {oldval: old, newval: this.ruta});\n               }\n\n            },\n            enumerable: true,\n            configurable: false\n         }\n         // Fin issue #47\n      });\n      \n      // modifica el menú contextual del origen.\n      this.on(\"isochroneset\", e => {\n         if(this.options.light && this.origen) {\n            this.origen.unbindContextMenu();\n            this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n         }\n      });\n\n      // Issue #46\n      // Asociamos un evento \"geocode\" al momento en que\n      // averiguamos la dirección postal del origen.\n      this.on(\"originset\", e => {\n         if(!e.newval) return;\n         crearAttrEvent.call(e.newval, \"postal\", \"geocode\");\n         // Incluimos la dirección como title y deshabilitamos\n         // la posibilidad de obtenerla a través del menú contextual.\n         e.newval.on(\"geocode\", x => {\n            e.newval.getElement().setAttribute(\"title\", x.newval);\n            if(this.options.light) {\n               e.newval.unbindContextMenu();\n               e.newval.bindContextMenu(iface.contextMenu.origen.call(this));\n            }\n         });\n      });\n\n      // Elimina la isocrona al fijar un nuevo origen.\n      this.on(\"originset\", e => this.setIsocronas(null));\n      // Fin issue #46\n\n      // Issue #47\n      this.on(\"routeset\", e => {\n         if(!this.options.light) return;\n\n         if(e.newval) {\n            const destino = e.newval.destino;\n            destino.unbindContextMenu();\n            destino.bindContextMenu(iface.contextMenu.centro.call(this, destino));\n         }\n         if(e.oldval) {\n            const destino = e.oldval.destino;\n            destino.unbindContextMenu();\n            destino.bindContextMenu(iface.contextMenu.centro.call(this, destino));\n         }\n         if(this.origen) {\n            this.origen.unbindContextMenu();\n            this.origen.bindContextMenu(iface.contextMenu.origen.call(this));\n         }\n      });\n      // Al cambiar de origen, hay que cambiar los menús contextuales de\n      // todas las marcas, ya que no tiene sentido la entrada de crear ruta.\n      this.on(\"originset\", e => {\n         if(this.ruta) this.setRuta(null);\n\n         if(!this.options.light) return;\n         for(const c of this.Centro.store) {\n            c.unbindContextMenu();\n            c.bindContextMenu(iface.contextMenu.centro.call(this, c));\n         }\n      });\n      // Fin issue #47\n\n      // Issue #55\n      this.on(\"routeset\", e => {\n         if(e.newval) {\n            e.newval.destino.once(\"remove\", e => {\n               // Al desaparecer el centro, hay ruta y él es el destino.\n               if(this.ruta.destino === e.target) {\n                  this.setRuta(null);\n                  // La ruta se despidió a la francesa; vamos, que se fue\n                  // porque desapareció el destino, y no por haberse eliminado.\n                  e.target._francesa = true;\n               }\n            });\n            e.newval.destino.once(\"add\", e => {\n               // Al volver a aparecer, él sigue siendo el destino\n               if(this.ors.ruta.calc.destino === e.target && e.target._francesa) {\n                  this.setRuta(e.target);\n               }\n               delete e.target._francesa;\n            });\n         }\n      });\n      // Fin issue #55\n   }\n}\n\nexport default load;\n","// status: Issues #57 y #62.\n\nfunction getOpts(status) {\n   status = JSON.parse(atob(status));\n\n   const ret = {\n      zoom: status.zoo,\n      center: status.cen\n   }\n   delete status.zoo;\n   delete status.cen;\n   ret.status = status;\n\n   return ret;\n}\n\n\n// Issue #62\n/**\n * Construye el status según se producen eventos sobre el mapa.\n * @this MapAdjOfer.prototype\n */\nfunction build() {\n   Object.defineProperty(this, \"status\", {\n      value: {},\n      writable:false,\n      enumerable: true,\n      configurable: false,\n   });\n\n   Object.defineProperties(this.status, {\n      zoo: {\n         get: () => this.map.getZoom(),\n         enumerable: true\n      },\n      cen: {\n         get: () => getCoords(this.map.getCenter()),\n         enumerable: true\n      }\n   })\n\n   // Reduce los decimales de las coordenadas a 4.\n   function getCoords(point) {\n      return [Number(point.lat.toFixed(4)), Number(point.lng.toFixed(4))];\n   }\n\n   this.map.on(\"zoomend\", e => { \n      this.fire(\"statuschange\", {attr: \"zoo\"});\n   });\n\n   this.map.on(\"moveend\", e => { \n      this.fire(\"statuschange\", {attr: \"cen\"});\n   });\n\n   this.on(\"originset\", e => {\n      if(e.newval) this.status.ori = getCoords(e.newval.getLatLng());\n      else delete this.status.ori;\n      if(e.newval !== e.oldval) this.fire(\"statuschange\", {attr: \"ori\"});\n   });\n\n   // Especialidad\n   this.on(\"dataloaded\", e => {\n      if(this.general) this.status.esp = this.general.entidad[0];\n      this.fire(\"statuschange\", {attr: \"esp\"});\n   });\n\n   this.on(\"markerselect\", e => {\n      if(e.newval) this.status.sel = this.seleccionado.getData().id.cod;\n      else delete this.status.sel;\n      if(e.newval !== e.oldval) this.fire(\"statuschange\", {attr: \"sel\"});\n   });\n\n   this.on(\"isochroneset\", e => {\n      const oldiso = this.status.iso;\n      if(e.newval) this.status.iso = 1;\n      else delete this.status.iso;\n      if(oldiso !== this.status.iso) this.fire(\"statuschange\", {attr: \"iso\"});\n   })\n\n   this.on(\"routeset\", e => {\n      if(e.newval) this.status.des = this.ruta.destino.getData().id.cod;\n      else delete this.status.des;\n      if(e.oldval !== e.newval) this.fire(\"statuschange\", {attr: \"des\"});\n   })\n\n   // Anota en el estado un filtro\n   function filterStatus(Marker, e) {\n      const filter = this[Marker].prototype.options.filter;\n      this.status.fil = this.status.fil || {};\n      this.status.fil[Marker] = this.status.fil[Marker] || {};\n\n      this.status.fil[Marker][e.name] = filter.getParams(e.name);\n      if(Marker === \"Centro\" && e.name === \"lejos\") {\n         // Nos cargamos el área que puede volver\n         // a hallarse y ocupa muchísimo espacio.\n         delete this.status.fil[Marker].lejos.area;\n      }\n      this.fire(\"statuschange\", {attr: `fil.${Marker}.${e.name}`});\n   }\n\n   // Desanota en el estado un filtro.\n   function unfilterStatus(Marker, e) {\n      delete this.status.fil[Marker][e.name];\n      if(Object.keys(this.status.fil[Marker]).length === 0) delete this.status.fil[Marker];\n      if(Object.keys(this.status.fil).length === 0) delete this.status.fil;\n      this.fire(\"statuschange\", {attr: `fil.${Marker}.${e.name}`});\n   }\n\n   this.Centro.on(\"filter:*\", filterStatus.bind(this, \"Centro\"));\n   this.Centro.on(\"unfilter:*\", unfilterStatus.bind(this, \"Centro\"));\n   this.Localidad.on(\"filter:*\", filterStatus.bind(this, \"Localidad\"));\n   this.Localidad.on(\"unfilter:*\", unfilterStatus.bind(this, \"Localidad\"));\n\n   this.Centro.on(\"correct:*\", e => {\n      if(e.auto || e.name === \"extinta\") return;  // Sólo se apuntan las manuales.\n      const corr = this.Centro.prototype.options.corr,\n            opts = corr.getOptions(e.name);\n\n      this.status.cor = this.status.cor || {};\n      this.status.cor[e.name] = {par: opts.params, aut: opts.auto};\n      this.fire(\"statuschange\", {attr: `cor.${e.name}`});\n   });\n            \n   this.Centro.on(\"uncorrect:*\", e => {\n      if(e.auto || e.name === \"extinta\") return;\n\n      delete this.status.cor[e.name];\n      if(Object.keys(this.status.cor).length === 0) delete this.status.cor;\n      this.fire(\"statuschange\", {attr: `cor.${e.name}`});\n   });\n\n   this.on(\"requestchange\", e => {\n      this.status.list = this.solicitud.list;\n      this.fire(\"statuschange\", {attr: \"pet\"});\n   });\n}\n// Fin issue #62\n\n\n/**\n * Fija la vista inicial del mapa en función del estado\n * que se haya pasado a través del parámetro URL status.\n *\n */\nfunction set() {\n   const status = this.options.status;\n\n   let lejos;\n\n   // Los filtros pueden aplicarse antes de obtener datos.\n   if(status.fil) {\n      // Pero este lo dejamos para después.\n      if(status.fil.Centro && status.fil.Centro.lejos) {\n         lejos = status.fil.Centro.lejos;\n         delete status.fil.Centro.lejos;\n      }\n      for(const Marker in status.fil) {\n         for(const name in status.fil[Marker]) {\n            this[Marker].filter(name, status.fil[Marker][name]);\n         }\n      }\n   }\n\n   if(status.esp) {  // Debe cargarse una especialidad.\n      this.once(\"dataloaded\", e => {\n         if(status.sel) this.seleccionado = this.Centro.get(status.sel);\n\n         if(status.cor) {\n            // Diferimos un cuarto de segundo la ejecución de las correcciones\n            // para darle tiempo a la interfaz visual a prepararse.\n            setTimeout(() => {\n               for(const name in status.cor) {\n                  const opts = status.cor[name];\n                  this.Centro.correct(name, opts.par, !!opts.aut);\n               }\n               this.Centro.invoke(\"refresh\");\n            }, 250);\n         }\n\n         if(this.ors && status.des) {\n            const destino = this.Centro.get(status.des);\n            if(status.iso) this.on(\"routeset\", e => this.setIsocronas());\n            this.setRuta(destino);\n         }\n      });\n      this.agregarCentros(`../../json/${status.esp}.json`);\n   }\n\n   // Origen\n   if(status.ori) this.setOrigen({lat: status.ori[0], lng: status.ori[1]});\n\n   // Isocronas: se está suponiendo que tardan bastante más\n   // que en cargar los datos de los centros. En puridad, habría\n   // que meterlo dentro del dataloaded anterior\n   if(this.ors && status.iso) {\n      if(lejos) {\n         this.once(\"isochroneset\", e => {\n            const area = this.getIsocronas(true)[lejos.idx];\n            this.ors.isocronas.dibujarAreaMaciza(area);\n            this.Centro.filter(\"lejos\", {area: area, idx: lejos.idx});\n            this.Centro.invoke(\"refresh\");\n         });\n      }\n      // Si hay que pintar una ruta, se generan las isocronas\n      // después para evitar que interfieran las dos cargas (ambas cargan loading).\n      if(!status.des) this.setIsocronas();\n   }\n\n   this.status.list = status.list;\n\n}\n\n\n/**\n * Obtiene un objeto codificado en base64 que describe el estado del mapa.\n * @param {Object} extra   Opciones extra que proporciona la interfaz visual\n * y que se añadiran al estado a través del atributo ``extra``.\n */\nfunction get(extra) {\n                  // Issue #66\n   const status = extra?Object.assign({visual: extra}, this.status)\n                       :this.status;\n   return btoa(JSON.stringify(status));\n}\n\nexport {getOpts, build, set, get}\n","/**\n * Registra las correcciones disponibles.\n * @this {MapAdjOfer} El objeto que implemnta el mapa\n * @private\n */\nexport default function() {\n   const self = this;\n\n   // Función para determinar si unas condiciones implican otras.\n   // Es aplicable a opciones que consisten en un array con valores.\n   // Por ejemplo: {bil: [\"Inglés\", \"Francés\"]} que implica que se\n   // eliminan enseñanzas que cumplan con alguno de los valores. En\n   // este caso, bilingües de Inglés o de Francés.\n   // Sin tener en cuenta inv, si los elementos antiguos incluyen a\n   // todos los nuevos, la corrección antigua incluye a la nueva.\n   // Por tanto, debe devolverse verdadero cuando\n   // (N=nuevos; y=interseccion; o=unión; A=antiguos):\n   //\n   // NyA = N\n   // !AyN = Vacio\n   // !Ny!A = !A\n   // Ao!N = Todos\n   function applyConInv(attr, todos, oldopts, newopts) {\n      if(!oldopts.inv && newopts.inv) {  //A, !N\n         const union = [].concat(oldopts[attr]);\n         for(const p of newopts[attr]) {\n            if(oldopts[attr].indexOf(p) === -1) union.push(p);\n         }\n         return union.length === todos.length;\n      }\n      else {\n         const inters = [];\n         for(const p of newopts[attr]) {\n            if(oldopts[attr].indexOf(p) !== -1) inters.push(p);\n         }\n         if(newopts.inv) return inters.length === oldopts[attr].length;  //!N, !A\n         else {\n            if(oldopts.inv) return inters.length === 0;  // !A, N\n            else return inters.length === newopts[attr].length; // N, A\n         }\n      }\n   }\n\n   // El GeoJSON con carácter informativo incluye el primer año\n   // de su extinción una enseñanza ya desaparecida. Debemos\n   // eliminarla aplicándole esta corrección atuomáticamente.\n   this.Centro.register(\"extinta\", {\n      attr: \"oferta\",\n      // opts= {}\n      func: function(idx, oferta, opts) {\n         return oferta[idx].ext;\n      }\n   });\n   this.on(\"dataloaded\", e => {\n      this.Centro.correct(\"extinta\", {});\n   });\n\n   // Elimina enseñanzas bilingües\n   this.Centro.register(\"bilingue\", {\n      attr: \"oferta\",\n      // opts= { bil: [\"Inglés\", \"Francés\"] } => Elimina enseñanzas bilingües de inglés y francés.\n      func: function(idx, oferta, opts) {\n         return !!(opts.inv ^ (opts.bil.indexOf(oferta[idx].idi) !== -1));\n      },\n      apply: function(oldopts, newopts) {\n         // Las enseñanzas que no son bilingües, tiene idi a null.\n         return applyConInv(\"bil\", [\"Inglés\", \"Francés\", \"Alemán\", null], oldopts, newopts);\n      },\n      // Sólo son pertinentes los puestos no bilingües (o sí, si inv=true).\n      chain: [{\n         corr: \"adjpue\",\n         func: function(opts) {\n            const map = {  // TODO: Esto debería sacarse de la base de datos y estar en el geoJSON\n               \"Francés\": 10,\n               \"Inglés\": 11,\n               \"Alemán\": 12\n            };\n            const cod = Object.keys(map)\n                              .filter(idi => opts.bil.indexOf(idi) !== -1)\n                              .map(e => map[e]);\n            //Puestos a eliminar.\n            const puestos = Object.keys(self.general.puestos)\n                                  .filter(pue => opts.inv ^ cod.some(c => pue.startsWith(c)));\n            return puestos.length>0?{puesto: puestos}:false;\n         }\n      }]\n   });\n\n   // Añade vacantes telefónicas a las adjudicaciones.\n   this.Centro.register(\"vt+\", {\n      attr: \"adj\",\n      add: true,\n      func: function(idx, adj, opts) {\n         const data = this.getData(),\n               res = [];\n         for(const puesto in data.pla) {\n            for(let i=0; i<data.pla[puesto].vt; i++) res.push({\n               col: \"J\",\n               esc: [0, 0, 0],\n               pue: puesto,\n               pet: null,\n               // TODO:: ¿Qué narices es esto?A Posiblemente CGT.\n               per: false,\n               ubi: false\n            });\n         }\n         return res;\n      }\n   });\n\n   // Elimina las adjudicaciones de los puestos suministrados.\n   this.Centro.register(\"adjpue\", {\n      attr: \"adj\",\n      // opts= {puesto: [\"00590059\", \"11590107\"], inv: false}\n      func: function(idx, adj, opts) {\n         return !!(opts.inv ^ (opts.puesto.indexOf(adj[idx].pue) !== -1));\n      },\n      apply: function(oldopts, newopts) {\n         return applyConInv(\"puesto\", Object.keys(self.general.puestos), oldopts, newopts);\n      }\n   });\n\n   // Elimina las enseñanzas suministradas\n   this.Centro.register(\"ofens\", {\n      attr: \"oferta\",\n      // opts= {ens: [\"23GMSMR168\", \"23GSASI820\"], inv: false}\n      func: function(idx, oferta, opts) {\n         return !!(opts.inv ^ (opts.ens.indexOf(oferta[idx].ens) !== -1));\n      },\n      apply: function(oldopts, newopts) {\n         return applyConInv(\"ens\", Object.keys(self.general.ens), oldopts, newopts);\n      },\n      chain: [{\n         corr: \"adjpue\",\n         // Si alguna de las enseñanzas eliminadas, es la única\n         // que puede impartir un puesto, entonces debe eliminarse tal puesto.\n         func: function(opts) {\n            const ens = self.general.ens;\n            // Interesan las enseñanzas que no se eliminan.\n            if(!opts.inv) opts = {ens: Object.keys(ens).filter(e => opts.ens.indexOf(e) === -1)};\n\n            // Puestos impartidos exclusivamente por las enseñanzas eliminadas.\n            const pue = [];\n            for(let p of self.general.puestos) {\n               let impartido = false;\n               for(let e of opts.ens) {\n                  if(ens[e].puestos.indexOf(p) !== -1) {\n                     impartido = true;\n                     break;\n                  }\n               }\n               if(!impartido) pue.push(p);\n            }\n\n            return pue.length?{puesto: pue}:false;\n         }\n      }]\n   });\n\n   // Elimina adjudicaciones no telefónicas.\n   this.Centro.register(\"vt\", {\n      attr: \"adj\",\n      // Las peticiones telefónicas son las que tiene pet=null\n      func: (idx, adj, opts) => adj[idx].pet !== null\n   });\n\n   // Elimina adjudicaciones que no responden a vacantes iniciales.\n   this.Centro.register(\"vi\", {\n      attr: \"adj\",\n      // opts= {}\n      func: function(idx, adj, opts) {\n         const puesto = adj[idx].pue,\n               vi = this.getData().pla[puesto].vi;\n         let i, num = 0;\n         for(i=0; i<=idx; i++) {\n            if(adj[i].pue === puesto) num++;\n         }\n         return i>vi;\n      }\n   });\n\n   // Elimina las enseñanzas no deseables.\n   /*\n   this.Centro.register(\"deseable\", {\n      attr: \"oferta\",\n      func: (idx, oferta, opts) => !oferta[idx].mar\n   });\n   */\n   // Esta implementación alternativa tiene la ventaja\n   // de que está expresada en términos de enseñanzas (ofens).\n   this.Centro.register(\"deseable\", {\n      attr: \"oferta\",\n      autochain: true,\n      func: opts => false,\n      chain: [{\n         corr: \"ofens\",\n         func: function(opts) {\n            // Hay que montar este cirio, porque la característica mar (deseable)\n            // aparece en las enseñanzas de centro, pero no en la relación general\n            // de enseñanzas. Debería corregirse el geojson.\n            const indeseables = [];\n            for(const ens in self.general.ens) {\n               for(const c of this.store) {\n                  let found = false;\n                  for(const o of c.getData().oferta) {\n                     if(o.ens === ens) {\n                        found = true;\n                        if(!o.mar) indeseables.push(ens);\n                        break;\n                     }\n                  }\n                  if(found) break;\n               }\n            }\n            return indeseables.length?{ens: indeseables}:false;\n         }\n      }]\n   });\n\n   // Elimina las enseñanzas que sean del turno indicado.\n   this.Centro.register(\"turno\", {\n      attr: \"oferta\",\n      // opts= {turno: 1, inv: true}  => 1: mañana, 2: tarde\n      func: function(idx, oferta, opts) {\n         if(oferta[idx].tur === null) return false; // Semipresenciales\n         const map = {\n            \"matutino\": 1,\n            \"vespertino\": 2,\n            \"ambos\": 3\n         }\n         // ESO y BAC no tiene turno,\n         // pero si es enseñanza de adultos es por la tarde.\n         const turno = map[oferta[idx].tur || (oferta[idx].adu?\"vespertino\":\"matutino\")];\n\n         return !(opts.inv ^ !(turno & opts.turno));\n      }\n   });\n\n   // Función para comprobar el adjudicatario de referencia.\n   function adjref(idx, adj, opts) {\n      // Pasa el tiempo de servicio a un pseudoescalafon:\n      // Debe cumplir que a mayor tiempo de servicio, menor escalafón.\n      function ts2esc(ts) {\n         const hoy = new Date();\n\n         return hoy.getFullYear() +\n                String(hoy.getMonth()).padStart(2, \"0\") +\n                String(hoy.getDate()).padStart(2, \"0\") -\n                ts.map(e => String(e).padStart(2, \"0\")).join(\"\");\n      }\n\n      // Calcula un escalafón intercolectivo. Está constituido por la\n      // concatenación de:\n      // - Una primera parte que identifica la prioridad del colectivo.\n      //   (1, el más prioritario; 2 el segundo, etc.)\n      // - Un escalafón que se calcula del siguiente modo:\n      //     + El propio escalafón, si es un func. de carrera que no ha\n      //       cogido nunca excedencia.\n      //     + Para interinos, funcionarios sin escalafón o funcionarios\n      //       que en algún momento cogieron excedencia, un\n      //       escalafón obtenido con ts2esc().\n      function escEquiv(opts) {\n         let esc = opts.esc,\n             ts = opts.ts,\n             col = String(self.general.colectivos[opts.col].o);\n\n         // TODO: En el geojson los interinos deberían tener su ts\n         // en la propiedad ts; y los funcionarios tener un esc y un ts.\n         if(opts.col === \"J\") {\n            if(esc && esc.length) {  // Precaución: los interinos tiene ts en esc.\n               ts = esc;\n               esc = undefined;\n            }\n         }\n         else if(ts !== undefined) {  // Func. de carrera con dato de ts.\n            const aa = (new Date()).getFullYear() - esc.substring(0, 4) - 1;\n            // Esto significa que nunca ha cogido excendencia\n            if(aa === ts[0]) ts = undefined;\n         }\n\n         if(ts !== undefined) esc = ts2esc(ts);\n\n         return Number(col + esc);\n      }\n\n      if(!opts.hasOwnProperty(\"_ref\")) opts._ref = escEquiv(opts);\n      return escEquiv(adj[idx]) < opts._ref;\n   }\n\n   // Elimina las adjudicaciones que sean más prioritarias\n   // que el adjudicatario de referencia que se defina.\n   this.Centro.register(\"adjref\", {\n      attr: \"adj\",\n      // opts= {ts: [10, 3, 22], esc: 20104120, col: \"DB\"}\n      // ts=tiempo-servicio (aa-mm-dd), esc=escalafon, col=colectivo\n      func: adjref\n   });\n\n   // Elimina enseñanzas que no sean nuevas\n   this.Centro.register(\"nueva\", {\n      attr: \"oferta\",\n      func: function(idx, oferta, opts) {\n         return oferta[idx].nue === 0;\n      }\n   });\n\n}\n","/**\n * Registra los filtros definidos para este tipo de mapa.\n * @this {MapAdjOfer} El objeto que implemnta el mapa\n * @private\n */\nexport default function() {\n   // Filtra según cantidad de adjudicaciones.\n   this.Centro.registerF(\"adj\", {\n      attrs: \"adj\",\n      // opts= {min: 0, inv: false}\n      func: function(opts) {\n          return !!(opts.inv ^ this.getData().adj.length < opts.min);\n      }\n   });\n\n   // Filtra según número de enseñanzas.\n   this.Centro.registerF(\"oferta\", {\n      attrs: \"oferta\",\n      // opts= {min: 0, inv: false}\n      func: function(opts) {\n          return !!(opts.inv ^ this.getData().oferta.length < opts.min);\n      }\n   });\n\n   // Elimina los tipos facilitados\n   this.Centro.registerF(\"tipo\", {\n      attrs: \"mod.dif\",\n      // opts= {tipo: 1, inv: false}  //tipo: 1=normal 2=compensatoria, 4=difícil desempeño\n      func: function(opts) {\n         const map  = { \"compensatoria\": 2, \"dificil\": 4 },\n               tipo = map[this.getData().mod.dif] || 1;\n\n         return !!(opts.inv ^ !!(tipo & opts.tipo));\n      }\n   });\n\n   // Elimina los centros que tengan alguna enseñanza del turno suministrado.\n   this.Centro.registerF(\"turno\", {\n      attrs: \"oferta\",\n      // opts= {turno: 1}  => 1: mañana, 2: tarde.\n      func: function(opts) {\n         const map = {\n            \"matutino\": 1,\n            \"vespertino\": 2,\n            \"ambos\": 3\n         }\n         for(const ens of this.getData().oferta.correctable) {\n            if(ens.filters.length > 0) continue; // Está filtrado.\n            if(ens.tur === null) continue;  // Semipresenciales.\n            const turno = map[ens.tur || (ens.adu?\"vespertino\":\"matutino\")];\n            if(turno & opts.turno) return true;\n         }\n         return false;\n      }\n   });\n\n   // Elimina las marcas que se hallen fuera del área\n   this.Centro.registerF(\"lejos\", {\n      attrs: \"no.existe\",\n      // opts={area: geojson}\n      func: function(opts) {\n         const latlng = this.getLatLng(),\n               point = {\n                  type: \"Feature\",\n                  geometry: {\n                     type: \"Point\",\n                     coordinates: [latlng.lng, latlng.lat]\n                  }\n               }\n\n         return !turf.booleanPointInPolygon(point, opts.area);\n      }\n   });\n\n   // Al eliminar las isocronas, desaplicamos el filtro lejos.\n   this.on(\"isochroneset\", e => {\n      if(!e.newval && this.Centro.hasFilter(\"lejos\")) {\n         this.Centro.unfilter(\"lejos\");\n         this.Centro.invoke(\"refresh\");\n      }\n   });\n}\n","import {getPath, rgb2hex, HSLtoRGB} from \"app/utils/misc.js\";\nimport svg from \"./images/boliche.svg\";\n\n// Definición del icono de centro\nconst converter = new L.utils.Converter([\"numvac\", \"tipo\", \"numofer\", \"bil\", \"ofervar\", \"sel\"])\n                             .define(\"tipo\", \"mod.dif\", t => t || \"normal\")\n                             .define(\"numvac\", \"adj\", a => a.length)\n                             .define(\"ofervar\", \"mod.cam\", c => c || 0)\n                             .define(\"sel\");\n\n// Para calcular la cantidad de oferta se considera\n// 1 una enseñanza deseable y 1/3 una que no lo es.\nconverter.define(\"numofer\", \"oferta\", function(oferta) {\n   let res = 0;\n   for(const ens of oferta) {\n      if(ens.filters.length>0) continue\n      res += ens.mar?3:1;\n   }\n   return Math.round(res/3);\n});\n\nconverter.define(\"bil\", \"oferta\", function(oferta) {\n   // Array.from(oferta) y no oferta, para usar el iterador y tener disponible \"filters\".\n   const idiomas = Array.from(oferta).map(ens => ens.filters.length===0 && ens.idi)\n                                            // Eliminamos valores nulos y valores repetidos.\n                                            .filter((idi, i, arr) => idi && arr.indexOf(idi) === i)\n\n   switch(idiomas.length) {\n      case 0:\n         return null;\n         break;\n      case 1:\n         return idiomas[0];\n         break;\n      default:\n         return \"multi\";\n   }\n});\n\nconst updater = (function(o) {\n   const paletaOferta = new Array(5).fill(null);\n   const paletaPlazas = new Array(7).fill(null);\n\n   // Devuelve blanco o negro dependiendo de cuál contraste mejor con el\n   // color RGB suministrado como argumento\n   function blancoNegro(rgb) {\n      var y = 2.2;\n\n      return (0.2126*Math.pow(rgb[0]/255, y) + 0.7152*Math.pow(rgb[1]/255, y) + 0.0722*Math.pow(rgb[2]/255, y) > Math.pow(0.5, y))?\"#000\":\"#fff\";\n   }\n\n   paletaOferta[0] = \"black\";\n   for(let i=1; i < paletaOferta.length; i++) {\n      paletaOferta[i] = rgb2hex(HSLtoRGB(i/(paletaOferta.length-1)));\n   }\n\n   var tintaPlazas = new Array(paletaPlazas).fill(null);\n   paletaPlazas[0] = tintaPlazas[0] = \"black\";\n   for(let i=1; i < paletaPlazas.length; i++) {\n      let color = HSLtoRGB(i/(paletaPlazas.length-1));\n      paletaPlazas[i] = rgb2hex(color);\n      tintaPlazas[i] = blancoNegro(color);\n   }\n\n   function updater(o) {\n      const defs = this.querySelector(\"defs\");\n      const content = this.querySelector(\".content\");\n\n      var e = this.querySelector(\".ofervac\");\n      if(o.numofer !== undefined) {\n         let x = e.querySelector(\"circle\");\n         x.setAttribute(\"fill\", paletaOferta[Math.min(paletaOferta.length-1, o.numofer)]);\n      }\n\n      if(o.numvac !== undefined) {\n         let i = Math.min(paletaPlazas.length-1, o.numvac);\n         e = e.querySelector(\"path\");\n         e.setAttribute(\"fill\", paletaPlazas[i]);\n         e = e.nextElementSibling;\n         e.textContent = o.numvac;\n         e.setAttribute(\"fill\", tintaPlazas[i]);\n      }\n\n      if(o.ofervar !== undefined) {\n         e = this.querySelector(\".ofervar\");\n         if(!o.ofervar) e.setAttribute(\"display\", \"none\");\n         else {\n            e.removeAttribute(\"display\");\n            e = e.firstElementChild.nextElementSibling;\n            if(o.ofervar > 0) e.removeAttribute(\"display\");\n            else e.setAttribute(\"display\", \"none\");\n         }\n      }\n\n      if(o.bil !== undefined) {\n         e = content.querySelector(\".bil\");\n         if(e) defs.appendChild(e);\n         if(o.bil !== null) content.appendChild(defs.querySelector(\".bil.\" + o.bil));\n      }\n\n      if(o.tipo !== undefined) {\n         e = content.querySelector(\".tipo\");\n         if(o.tipo === \"normal\") {\n            if(e) defs.appendChild(e);\n         }\n         else {\n            if(!e) {\n               e = defs.querySelector(\".tipo\");\n               content.appendChild(e);\n            }\n            if(o.tipo === \"dificil\") e.setAttribute(\"fill\", \"#c13\");\n            else e.setAttribute(\"fill\", \"#13b\"); \n         }\n      }\n\n      if(o.sel !== undefined) {\n         e = content.querySelector(\".selected\");\n         if(!o.sel) {\n            if(e) defs.appendChild(e);\n         }\n         else if(!e) {\n            e = defs.querySelector(\".selected\");\n            content.prepend(e);\n         }\n      }\n   }\n\n   return updater;\n})();\n\nconst url = getPath(svg);\n\nexport {converter, url, updater}\n","// Definición de los iconos CSS (comparten todo menos el estilo)\nconst converter = new L.utils.Converter([\"numvac\", \"tipo\"])\n                             .define(\"tipo\", \"mod.dif\", t => t || \"normal\")\n                             .define(\"numvac\", \"adj\", a => a.length);\n\nfunction updater(o) {\n   const content = this.querySelector(\".content\");\n   if(o.tipo) content.className = \"content \" + o.tipo;\n   if(o.numvac !== undefined) content.firstElementChild.textContent = o.numvac;\n   return this;\n}\n\nconst html = '<div class=\"content\"><span></span></div><div class=\"arrow\"></div>';\n\nexport {converter, html, updater};\n","module.exports = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA5MCA5MCI+CgogICA8ZGVmcz4KICAgICAgPCEtLSBCYW5kZXJhIGZyYW5jZXNhIC0tPgogICAgICA8ZyBjbGFzcz0iYmlsIEZyYW5jw6lzIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZS13aWR0aD0iMCI+CiAgICAgICAgIDxyZWN0IHg9IjIiIHk9IjQiIHdpZHRoPSIxMiIgaGVpZ2h0PSIyNCIgZmlsbD0iIzAwNGRmZiIgLz4KICAgICAgICAgPHJlY3QgeD0iMTQiIHk9IjQiIHdpZHRoPSIxMiIgaGVpZ2h0PSIyNCIgZmlsbD0iI2ZmZiIgLz4KICAgICAgICAgPHJlY3QgeD0iMjYiIHk9IjQiIHdpZHRoPSIxMiIgaGVpZ2h0PSIyNCIgZmlsbD0iI2ZmMTkyNCIgLz4KICAgICAgPC9nPgoKICAgICAgPCEtLSBCYW5kZXJhIGFsZW1hbmEgLS0+CiAgICAgIDxnIGNsYXNzPSJiaWwgQWxlbcOhbiIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2Utd2lkdGg9IjAiPgogICAgICAgICA8cmVjdCB4PSIyIiB5PSI0IiB3aWR0aD0iMzYiIGhlaWdodD0iOCIgZmlsbD0iIzAwMCIgLz4KICAgICAgICAgPHJlY3QgeD0iMiIgeT0iMTIiIHdpZHRoPSIzNiIgaGVpZ2h0PSI4IiBmaWxsPSIjZjAwIiAvPgogICAgICAgICA8cmVjdCB4PSIyIiB5PSIyMCIgd2lkdGg9IjM2IiBoZWlnaHQ9IjgiIGZpbGw9IiNmYzAiIC8+CiAgICAgIDwvZz4KCiAgICAgIDwhLS0gQmFuZGVyYSBSZWlubyBVbmlkbyAtLT4KICAgICAgPGcgY2xhc3M9ImJpbCBJbmdsw6lzIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZS13aWR0aD0iMCI+CiAgICAgICAgIDxyZWN0IHg9IjIiIHk9IjQiIHdpZHRoPSIzNiIgaGVpZ2h0PSIyNCIgZmlsbD0iIzAwZiIgLz4KICAgICAgICAgPHBhdGggZD0iTSAyIDQgaCAzIEwgMzggMjUgdiAzIGggLTMgTCAyIDcgeiIgZmlsbD0iI2ZmZiIgLz4KICAgICAgICAgPHBhdGggZD0iTSAyIDQgTCAyMCAxNiB2IDIgTCAyIDYgeiIgZmlsbD0iI2YwMCIgLz4KICAgICAgICAgPHBhdGggZD0iTSAzOCAyOCBMIDIwIDE2IHYgLTIgTCAzOCAyNiB6IiBmaWxsPSIjZjAwIiAvPgogICAgICAgICA8cGF0aCBkPSJNIDM4IDQgaCAtMyBMIDIgMjUgdiAzIGggMyBMIDM4IDcgeiIgZmlsbD0iI2ZmZiIgLz4KICAgICAgICAgPHBhdGggZD0iTSAzOCA0IEwgMjAgMTYgaCAtMiBMIDM2IDQgeiIgZmlsbD0iI2YwMCIgLz4KICAgICAgICAgPHBhdGggZD0iTSAyIDI4IEwgMjAgMTYgaCAyIEwgNCAyOCB6IiBmaWxsPSIjZjAwIiAvPgogICAgICAgICA8cmVjdCB4PSIxNyIgeT0iNCIgd2lkdGg9IjYiIGhlaWdodD0iMjQiIGZpbGw9IiNmZmYiIC8+CiAgICAgICAgIDxyZWN0IHg9IjE4IiB5PSI0IiB3aWR0aD0iNCIgaGVpZ2h0PSIyNCIgZmlsbD0iI2YwMCIgLz4KICAgICAgICAgPHJlY3QgeD0iMiIgeT0iMTMiIHdpZHRoPSIzNiIgaGVpZ2h0PSI2IiBmaWxsPSIjZmZmIiAvPgogICAgICAgICA8cmVjdCB4PSIyIiB5PSIxNCIgd2lkdGg9IjM2IiBoZWlnaHQ9IjQiIGZpbGw9IiNmMDAiIC8+CiAgICAgIDwvZz4KCiAgICAgIDwhLS0gQmFuZGVyYSBhenVsIC0tPgogICAgICA8ZyBjbGFzcz0iYmlsIG11bHRpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZS13aWR0aD0iMCI+CiAgICAgICAgIDxyZWN0IHg9IjIiIHk9IjQiIHdpZHRoPSIzNiIgaGVpZ2h0PSIyNCIgZmlsbD0iIzAwMTQ4OSIgLz4KICAgICAgPC9nPgoKICAgICAgPCEtLSBUaXBvIGRlIGNlbnRybzogY29tcGVuc2F0b3JpYSBvIGRpZsOtY2lsIGRlc2VtcGXDsW8gLS0+CiAgICAgIDwhLS0gZGlmaWNpbCAjYzEzIC0tPgogICAgICA8Y2lyY2xlIGNsYXNzPSJ0aXBvIiBjeD0iNjkiIGN5PSI3NCIgcj0iOSIgZmlsbD0iIzEzYiIgLz4KCiAgICAgIDwhLS0gQ8OtcmN1bG8gZGUgc2VsZWNjacOzbiAtLT4KICAgICAgPHBhdGggY2xhc3M9InNlbGVjdGVkIiBkPSJNIDYgNDIgYSAzOCAzOCAwIDEgMSAwIDAuMDAwMDEiIHN0cm9rZS13aWR0aD0iNiIgc3Ryb2tlPSJyZWQiIGZpbGwtb3BhY2l0eT0iMCIgLz4KICAgPC9kZWZzPgoKICAgPGcgY2xhc3M9ImNvbnRlbnQiPgogICAgICA8cGF0aCBkPSJNIDQ0IDgwLjMwMTI3IGEgMjUgMjUgMCAwIDAgLTEyLjUgLTIxLjY1MDYzNSBhIDI1IDI1IDAgMSAxIDI1IDAgYSAyNSAyNSAwIDAgMCAtMTIuNSAyMS42NTA2MzUiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtb3BhY2l0eT0iMSIvPgogICAgICA8IS0tIE9mZXJ0YSAoaXpxdWllcmRhKSB5IHBsYXphcyAoZGVyZWNoYSkKICAgICAgICAtICBFbCBjb2xvciBjYW1iaWEgc2Vnw7puIGxhIGNhbnRpZGFkIGRlIG9mZXJ0YSB5IGRlIHBsYXphcy4gMCA9IG5lZ3JvLgogICAgICAgIC0gIEN1YW5kbyBubyBoYXkgcGxhemFzLCBlbCBjb2xvciBkZSBsYXMgcGxhemFzID0gb2ZlcnRhLgogICAgICAgIC0tPgogICAgICA8ZyBjbGFzcz0ib2ZlcnZhYyIgZmlsbC1vcGFjaXR5PSIxIj4KICAgICAgICAgPCEtLQogICAgICAgICA8cGF0aCBkPSJNIDQ0IDU3IGEgMjAgMjAgMCAxIDEgMCAtNDAgWiIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsPSJncmVlbiIgLz4KICAgICAgICAgLS0+CiAgICAgICAgIDxjaXJjbGUgY3g9IjQ0IiBjeT0iMzciIHI9IjIwIiBmaWxsPSJncmVlbiIgLz4KICAgICAgICAgPHBhdGggZD0iTSA0NCAxNyBhIDIwIDIwIDAgMSAxIDAgNDAgWiIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsPSJ5ZWxsb3ciICAvPgogICAgICAgICA8dGV4dCB4PSI1MyIgeT0iNDUiIGZpbGw9ImJsYWNrIiBmb250LXNpemU9IjI2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiI+ODwvdGV4dD4KICAgICAgPC9nPgoKICAgICAgPCEtLSArLCAtIG8gbmFkYSwgZGVwZW5kaWVuZG8gZGUgbGEgb2ZlcnRhIC0tPgogICAgICA8ZyBkaXNwbGF5PSJub25lIiBjbGFzcz0ib2ZlcnZhciIgZmlsbC1vcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9IjYiIHN0cm9rZT0iYmxhY2siPgogICAgICAgICA8cGF0aCBkPSJNIDYyIDE0IGggMjAiIC8+CiAgICAgICAgIDxwYXRoIGQ9Ik0gNzIgNCB2IDIwIiAvPgogICAgICA8L2c+CgogICA8L2c+Cjwvc3ZnPgo=\"","module.exports = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA5MCA5MCI+CiAgIDxkZWZzPgogICAgICA8cGF0aCBjbGFzcz0ic2VsZWN0ZWQiIGQ9Ik0gNiA0MiBhIDM4IDM4IDAgMSAxIDAgMC4wMDAwMSIgc3Ryb2tlLXdpZHRoPSI2IiBzdHJva2U9InJlZCIgZmlsbC1vcGFjaXR5PSIwIiAvPgogICA8L2RlZnM+CgogICA8ZyBjbGFzcz0iY29udGVudCI+CiAgICAgIDxwYXRoIGQ9Ik0gNDQgODAuMzAxMjcgYSAyNSAyNSAwIDAgMCAtMTIuNSAtMjEuNjUwNjM1IGggMjUgYSAyNSAyNSAwIDAgMCAtMTIuNSAyMS42NTA2MzUiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtb3BhY2l0eT0iMSIvPgogICAgICA8cmVjdCB4PSIxOSIgeT0iMTIiIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgZmlsbD0iYmxhY2siIC8+CiAgICAgIDwhLS0gdGFtYcOxbyAyOCBzaSB0aWVuZSAzIG8gbcOhcyBjaWZyYXMgLS0+IAogICAgICA8dGV4dCB4PSI0NCIgeT0iNDgiIHN0cm9rZT0iI2VlNiIgZmlsbD0iI2VlNiIgZm9udC1zaXplPSIzMiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9Im1vbm9zcGFjZSI+MDwvdGV4dD4KICAgPC9nPgo8L3N2Zz4K\"","/**\n * Catálogo de iconos para el centro\n */\nimport * as css from \"./css.js\";\nimport * as boliche from \"./boliche.js\";\nimport * as solicitud from \"./solicitud.js\";\nimport {getPath} from \"app/utils/misc.js\";\nimport \"./sass/piolin.sass\";\nimport \"./sass/chupachups.sass\";\n\nexport default {\n   piolin: L.utils.createMutableIconClass(\"piolin\", {\n      iconSize: null,\n      iconAnchor: [12.5, 34],\n      // css: getPath(\"css/piolin.css\"),  // Incluimos las reglas en el CSS general\n      html: css.html,\n      converter: css.converter,\n      updater: css.updater\n   }),\n   chupachups: L.utils.createMutableIconClass(\"chupachups\", {\n      iconSize: [25, 34],\n      iconAnchor: [12.5, 34],\n      // css: getPath(\"css/chupachups.css\"),\n      html: css.html,\n      converter: css.converter,\n      updater: css.updater\n   }),\n   solicitud: L.utils.createMutableIconClass(\"solicitud\", {\n      iconSize: [40, 40],\n      iconAnchor: [19.556, 35.69],\n      url: solicitud.url,\n      converter: solicitud.converter,\n      updater: solicitud.updater\n   }),\n   boliche: L.utils.createMutableIconClass(\"boliche\", {\n      iconSize: [40, 40],\n      iconAnchor: [19.556, 35.69],\n      url: boliche.url,\n      converter: boliche.converter,\n      updater: boliche.updater,\n   })\n}\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","import {getPath} from \"app/utils/misc.js\";\nimport svg from \"./images/solicitud.svg\";\n\n// Definición del icono de solicitud\nconst converter = new L.utils.Converter([\"peticion\", \"sel\"])\n                             .define(\"peticion\")\n                             .define(\"sel\");\n\nfunction updater(o) {\n   var text = this.querySelector(\"text\");\n   if(o.peticion !== undefined) {\n      text.textContent = o.peticion;\n      var size = (o.peticion.toString().length > 2)?28:32;\n      text.setAttribute(\"font-size\", size);\n   }\n\n   if(o.sel !== undefined) {\n      const content = this.querySelector(\".content\"),\n            defs    = this.querySelector(\"defs\");\n      let   e       = content.querySelector(\".selected\");\n      if(!o.sel) {\n         if(e) defs.appendChild(e);\n      }\n      else if(!e) {\n         e = defs.querySelector(\".selected\");\n         content.prepend(e);\n      }\n   }\n   return this;\n}\n\nconst url = getPath(svg);\n\nexport {converter, url, updater}\n","import createCorrections from \"./corrections.js\";\nimport createFilters from \"./filters.js\";\nimport catalogo from \"./icons/index.js\";\n\n/**\n* Crea la clase de marca para los centros y le\n* añade las correcciones y filtros definidos para ella.\n* @this {MapAdjOfer} El objeto que implemnta el mapa\n* @private\n*/\nfunction create() {\n   /**\n   * Clase de marca para los centros educativos.\n   * @memberof MapAdjOfer.prototype\n   * @type {Marker}\n   */\n   this.Centro = L.Marker.Mutable.extend({\n      statics: {\n         /**\n          * Obtiene la marca de un centro a partir de su código.\n          * @param {String|Number} codigo  El código del centro.\n          * @returns {L.Marker} La marca del centro cuyo código es el suministrado.\n          */\n         get: function(codigo) {\n            if(typeof codigo === \"string\" && codigo.endsWith(\"C\")) codigo = codigo.slice(0, -1);\n            for(const c of this.store) {\n               if(c.getData().id.cod == codigo) return c;\n            }\n         }\n      },\n      options: {\n         mutable: \"feature.properties\",\n         filter: this.cluster,\n      }\n   });\n\n   createCorrections.call(this);\n   createFilters.call(this);\n}\n\nexport {create, catalogo}\n","import mapAdjOfer from \"./adjofer/index.js\";\nexport default mapAdjOfer;\n","import {getPath} from \"app/utils/misc.js\";\nimport zoomIn from \"./images/zoom-in.png\";\nimport zoomOut from \"./images/zoom-out.png\";\n\n// Para asegurarnos de que ProvidePlugin (webpack)\n// cargará el código.\nL.Map.ContextMenu;\n\n/**\n* Define el menú contextual del mapa.\n* @this {MapAdjOfer}  El objeto del mapa de adjudicaciones.\n*/\nfunction map() {\n   return {\n      contextmenu: true,\n      contextmenuItems: [\n         {\n            text: \"Fijar origen de viaje\",\n            callback: e => this.setOrigen(e.latlng)\n         },\n         {\n            text: \"Centrar el mapa aquí\",\n            callback: e => this.map.panTo(e.latlng)\n         },\n         \"-\",\n         {\n            text: \"Ampliar escala\",\n            icon: getPath(zoomIn),\n            callback: e => this.map.zoomIn()\n         },\n         {\n            text: \"Reducir escala\",\n            icon: getPath(zoomOut),\n            callback: e => this.map.zoomOut()\n         }\n      ]\n   }\n}\n\n\n/**\n* Define el menú contextual del punto de origen\n* @this {MapAdjOfer}  El objeto del mapa de adjudicaciones.\n*\n* @param {String} espera  Cuál es la acción por la que se está esperando.\n*/\nfunction origen() {\n   const items = [\n      {\n         text: \"Geolocalizar este origen\",\n         disabled: !!this.origen.postal || this.ors.espera.indexOf(\"geocode\") !== -1,\n         callback: e => this.calcularOrigen()\n      }\n   ]\n\n   if(this.isocronas) {\n      items.push({\n         text: \"Eliminar isocronas\",\n         callback: e => this.setIsocronas(null)\n      });\n   }\n   else {\n      items.push({\n         text: \"Generar isocronas\",\n         disabled: this.ors.espera.indexOf(\"isocronas\") !== -1,\n         callback: e => this.setIsocronas(true)\n      });\n   }\n\n   if(this.ruta || this.ors.espera.indexOf(\"ruta\") !== -1) {\n      items.push({\n         text: \"Eliminar ruta\",\n         disabled: this.ors.espera.indexOf(\"ruta\") !== -1,\n         callback: e => this.setRuta(null)\n      });\n   }\n   else {\n      items.push({\n         text: \"Crear ruta al centro seleccionado\",\n         disabled: !this.seleccionado,\n         callback: e => this.setRuta(this.seleccionado)\n      });\n   }\n\n   items.push.apply(items, [\n      \"-\",\n      {\n         text: \"Eliminar este origen\",\n         callback: e => this.setOrigen(null)\n      }\n   ]);\n\n   return {\n      contextmenu: true,\n      contextmenuInheritItems: false,\n      contextmenuItems: items\n   }\n}\n\nfunction centro(marker) {\n\n   const seleccion = this.seleccionado !== marker,\n         texto = (seleccion?\"Seleccionar\":\"Deseleccionar\") + \" el centro\",\n         items = [\n            {\n               text: texto,\n               callback: e => this.seleccionado = (seleccion?marker:null)\n            }\n         ]\n\n   if(this.ruta && this.ruta.destino === marker) {\n      items.push({\n         text: \"Eliminar la ruta\",\n         callback: e => this.setRuta(null)\n      });\n   }\n   else {\n      items.push({\n         text: \"Crear ruta desde el origien\",\n         disabled: !this.origen || this.ors.espera.indexOf(\"ruta\") !== -1,\n         callback: e => this.setRuta(marker)\n      });\n   }\n\n   return {\n      contextmenu: true,\n      contextmenuInheritItems: false,\n      contextmenuItems: items\n   }\n}\n\nexport {map, origen, centro}\n","module.exports = \"data:image/gif;base64,R0lGODlhKwALAPEAAP///12T36/J7l2T3yH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAKwALAAACMoSOCMuW2diD88UKG95W88uF4DaGWFmhZid93pq+pwxnLUnXh8ou+sSz+T64oCAyTBUAACH5BAkKAAAALAAAAAArAAsAAAI9xI4IyyAPYWOxmoTHrHzzmGHe94xkmJifyqFKQ0pwLLgHa82xrekkDrIBZRQab1jyfY7KTtPimixiUsevAAAh+QQJCgAAACwAAAAAKwALAAACPYSOCMswD2FjqZpqW9xv4g8KE7d54XmMpNSgqLoOpgvC60xjNonnyc7p+VKamKw1zDCMR8rp8pksYlKorgAAIfkECQoAAAAsAAAAACsACwAAAkCEjgjLltnYmJS6Bxt+sfq5ZUyoNJ9HHlEqdCfFrqn7DrE2m7Wdj/2y45FkQ13t5itKdshFExC8YCLOEBX6AhQAADsAAAAAAAAAAAA=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAEJGlDQ1BJQ0MgUHJvZmlsZQAAOBGFVd9v21QUPolvUqQWPyBYR4eKxa9VU1u5GxqtxgZJk6XtShal6dgqJOQ6N4mpGwfb6baqT3uBNwb8AUDZAw9IPCENBmJ72fbAtElThyqqSUh76MQPISbtBVXhu3ZiJ1PEXPX6yznfOec7517bRD1fabWaGVWIlquunc8klZOnFpSeTYrSs9RLA9Sr6U4tkcvNEi7BFffO6+EdigjL7ZHu/k72I796i9zRiSJPwG4VHX0Z+AxRzNRrtksUvwf7+Gm3BtzzHPDTNgQCqwKXfZwSeNHHJz1OIT8JjtAq6xWtCLwGPLzYZi+3YV8DGMiT4VVuG7oiZpGzrZJhcs/hL49xtzH/Dy6bdfTsXYNY+5yluWO4D4neK/ZUvok/17X0HPBLsF+vuUlhfwX4j/rSfAJ4H1H0qZJ9dN7nR19frRTeBt4Fe9FwpwtN+2p1MXscGLHR9SXrmMgjONd1ZxKzpBeA71b4tNhj6JGoyFNp4GHgwUp9qplfmnFW5oTdy7NamcwCI49kv6fN5IAHgD+0rbyoBc3SOjczohbyS1drbq6pQdqumllRC/0ymTtej8gpbbuVwpQfyw66dqEZyxZKxtHpJn+tZnpnEdrYBbueF9qQn93S7HQGGHnYP7w6L+YGHNtd1FJitqPAR+hERCNOFi1i1alKO6RQnjKUxL1GNjwlMsiEhcPLYTEiT9ISbN15OY/jx4SMshe9LaJRpTvHr3C/ybFYP1PZAfwfYrPsMBtnE6SwN9ib7AhLwTrBDgUKcm06FSrTfSj187xPdVQWOk5Q8vxAfSiIUc7Z7xr6zY/+hpqwSyv0I0/QMTRb7RMgBxNodTfSPqdraz/sDjzKBrv4zu2+a2t0/HHzjd2Lbcc2sG7GtsL42K+xLfxtUgI7YHqKlqHK8HbCCXgjHT1cAdMlDetv4FnQ2lLasaOl6vmB0CMmwT/IPszSueHQqv6i/qluqF+oF9TfO2qEGTumJH0qfSv9KH0nfS/9TIp0Wboi/SRdlb6RLgU5u++9nyXYe69fYRPdil1o1WufNSdTTsp75BfllPy8/LI8G7AUuV8ek6fkvfDsCfbNDP0dvRh0CrNqTbV7LfEEGDQPJQadBtfGVMWEq3QWWdufk6ZSNsjG2PQjp3ZcnOWWing6noonSInvi0/Ex+IzAreevPhe+CawpgP1/pMTMDo64G0sTCXIM+KdOnFWRfQKdJvQzV1+Bt8OokmrdtY2yhVX2a+qrykJfMq4Ml3VR4cVzTQVz+UoNne4vcKLoyS+gyKO6EHe+75Fdt0Mbe5bRIf/wjvrVmhbqBN97RD1vxrahvBOfOYzoosH9bq94uejSOQGkVM6sN/7HelL4t10t9F4gPdVzydEOx83Gv+uNxo7XyL/FtFl8z9ZAHF4bBsrEwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuMS4yIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzI8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzp0aXRsZT4KICAgICAgICAgICAgPHJkZjpBbHQ+CiAgICAgICAgICAgICAgIDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+Z2x5cGhpY29uczwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpBbHQ+CiAgICAgICAgIDwvZGM6dGl0bGU+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpAkTcwAAABm0lEQVQ4EYWTvUoDURCFZ4MaUB8iXUBBkKhEEUvB3kKwNIUPIAgmkB8wNunttBCsfIiACGI6SyubaGvlv8bv3MxdlyA4cPbMzD0z9+7c3cTMkgEGW5Ikq1AFLIAJ8AauwAmSG1iaVK/YVOv1h4TfSv2BT3KNjFZNhnVefJQp6uLvgBWwC7ogNq25/rcBi2sZQTPtbFZwcZ71Y9d8wCXP55zt1Be7mWLtrl0noxj/2nOdmBPnSC4C2ZkezEjFZfnYBnEZoWZzETJmy87aINgdTwUqLLiv+N39vu+47nHP4zAHnUBXJZtj4R6eAptgHMyAWSCbH5K9OgdSA92zbIvj5mnyjN8HD+CR+In8NP42kF0OyRJnW8LRPevYmnaYro4pYCo+BwrUvOj5scAeNFwgkaa9B/TO++AWKK9BfoG6arwuFxwPaizqniUexQs5Fcd8I9Mk/AuxYwlRB2guPaD3bYMiqIPYQNwKG/vuGkj6ecbuo4ymOdKkmr6CN9KtCKGhs+IwMNe0iONJDsKuJP41rlK3o0Hqa61ChIP2D+1yHjm+wtC9AAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAEJGlDQ1BJQ0MgUHJvZmlsZQAAOBGFVd9v21QUPolvUqQWPyBYR4eKxa9VU1u5GxqtxgZJk6XtShal6dgqJOQ6N4mpGwfb6baqT3uBNwb8AUDZAw9IPCENBmJ72fbAtElThyqqSUh76MQPISbtBVXhu3ZiJ1PEXPX6yznfOec7517bRD1fabWaGVWIlquunc8klZOnFpSeTYrSs9RLA9Sr6U4tkcvNEi7BFffO6+EdigjL7ZHu/k72I796i9zRiSJPwG4VHX0Z+AxRzNRrtksUvwf7+Gm3BtzzHPDTNgQCqwKXfZwSeNHHJz1OIT8JjtAq6xWtCLwGPLzYZi+3YV8DGMiT4VVuG7oiZpGzrZJhcs/hL49xtzH/Dy6bdfTsXYNY+5yluWO4D4neK/ZUvok/17X0HPBLsF+vuUlhfwX4j/rSfAJ4H1H0qZJ9dN7nR19frRTeBt4Fe9FwpwtN+2p1MXscGLHR9SXrmMgjONd1ZxKzpBeA71b4tNhj6JGoyFNp4GHgwUp9qplfmnFW5oTdy7NamcwCI49kv6fN5IAHgD+0rbyoBc3SOjczohbyS1drbq6pQdqumllRC/0ymTtej8gpbbuVwpQfyw66dqEZyxZKxtHpJn+tZnpnEdrYBbueF9qQn93S7HQGGHnYP7w6L+YGHNtd1FJitqPAR+hERCNOFi1i1alKO6RQnjKUxL1GNjwlMsiEhcPLYTEiT9ISbN15OY/jx4SMshe9LaJRpTvHr3C/ybFYP1PZAfwfYrPsMBtnE6SwN9ib7AhLwTrBDgUKcm06FSrTfSj187xPdVQWOk5Q8vxAfSiIUc7Z7xr6zY/+hpqwSyv0I0/QMTRb7RMgBxNodTfSPqdraz/sDjzKBrv4zu2+a2t0/HHzjd2Lbcc2sG7GtsL42K+xLfxtUgI7YHqKlqHK8HbCCXgjHT1cAdMlDetv4FnQ2lLasaOl6vmB0CMmwT/IPszSueHQqv6i/qluqF+oF9TfO2qEGTumJH0qfSv9KH0nfS/9TIp0Wboi/SRdlb6RLgU5u++9nyXYe69fYRPdil1o1WufNSdTTsp75BfllPy8/LI8G7AUuV8ek6fkvfDsCfbNDP0dvRh0CrNqTbV7LfEEGDQPJQadBtfGVMWEq3QWWdufk6ZSNsjG2PQjp3ZcnOWWing6noonSInvi0/Ex+IzAreevPhe+CawpgP1/pMTMDo64G0sTCXIM+KdOnFWRfQKdJvQzV1+Bt8OokmrdtY2yhVX2a+qrykJfMq4Ml3VR4cVzTQVz+UoNne4vcKLoyS+gyKO6EHe+75Fdt0Mbe5bRIf/wjvrVmhbqBN97RD1vxrahvBOfOYzoosH9bq94uejSOQGkVM6sN/7HelL4t10t9F4gPdVzydEOx83Gv+uNxo7XyL/FtFl8z9ZAHF4bBsrEwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuMS4yIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzI8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzp0aXRsZT4KICAgICAgICAgICAgPHJkZjpBbHQ+CiAgICAgICAgICAgICAgIDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+Z2x5cGhpY29uczwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpBbHQ+CiAgICAgICAgIDwvZGM6dGl0bGU+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpAkTcwAAABjklEQVQ4EXWTTStEURjHzzUjNhZWQjbElk+gCBvWs1AaL9nY2ln6ApYWmsxkoyxtNFY2SpZKWUhJylKR8jZ+/3OeZ1zTOPWb5/1/zz33TBZC6Gg0Gt/YkGXZAmYNxqATXuEEqvTcYNWT4Tfkx2V+D0ENVHC+cv4z/qr1SiA45EMBDsEHj/DLMAebcAVeWzQR7TqKUIvNaviAdS+4JdcHx6CeB+jPixCHC1Cx5kOtlppE7q0vPgQ/7gIbh9+xU6Y8K9+YwU5afg9fD6pYHAWKJLRe4JoDHsXWlcitR/xB0FlodSWTfl1AX2Ec5ToiA/if1pRhhdZEMuHNbNOc4WlrB9paO6gNw5P1ldXDap5ByQrKbrUKkBsCf8gtfq8JFKK1YJ+CBMQpbMA8bMMdKK/bqrNatpkO/MwvQzfBLrhIq9WVzueWJGJC6V0smKZRn+scLkFb120cgQq4iHZTjjM2+Od+K9cOhqo5EYmVmo0E+lz6X6R3S7FyiosuiF8F38mvgDf8ZxlKp56Ed4hX1PsD4iBETxvMaUUAAAAASUVORK5CYII=\"","import * as contextMenu from \"./contextmenu.js\";\nimport loading from \"./loading.js\"\nimport popupRuta from \"./popupruta.js\"\nimport progressBar from \"./progressbar.js\"\nimport searchBar from \"./searchbar.js\"\n\nimport \"./sass/adjofer.sass\";\n\nexport {contextMenu, loading, popupRuta, progressBar, searchBar}\n","import {getPath} from \"app/utils/misc.js\";\nimport loader from \"./images/ajax-loader.gif\";\n\n// tipo: isocronas, geocode, ruta.\nfunction ajaxGif(tipo) {\n   let loading;\n   \n   if(loading = L.DomUtil.get(\"leaflet-loading\")) {\n      L.DomUtil.remove(loading);\n   }\n   else {\n      loading = L.DomUtil.create(\"div\", \"leaflet-message leaflet-control\", \n                                 L.DomUtil.get(\"map\"));\n      loading.id = \"leaflet-loading\";\n      const img = document.createElement(\"img\");\n      img.setAttribute(\"src\", getPath(loader));\n      loading.appendChild(img);\n   }\n}\n\nexport default ajaxGif;\n","function popupRuta(destino, ruta) {\n   const container = document.createElement(\"article\"),\n         distancia = Math.floor(ruta.properties.summary.distance / 1000),\n         tiempo = (function(t) {  // Pasa segundos a horas y minutos.\n            let m = Math.floor(t/60);\n            if(m > 60) {\n               const h = Math.floor(m/60);\n               m %= 60;\n               return `${h}h ${m}m`;\n            }\n            else return m + \"m\";\n         })(ruta.properties.summary.duration);\n\n   let e = document.createElement(\"h3\");\n\n   e.textContent = destino.getData().id.nom;\n   container.appendChild(e);\n\n   let ul = document.createElement(\"ul\"),\n       li = document.createElement(\"li\");\n\n   ul.appendChild(li);\n   e = document.createElement(\"b\");\n   e.textContent = \"Distancia\";\n   li.appendChild(e);\n   li.appendChild(document.createTextNode(`: ${distancia} Km`));\n   \n   li = document.createElement(\"li\");\n   ul.appendChild(li);\n\n   e = document.createElement(\"b\");\n   e.textContent = \"Tiempo est.\";\n   li.appendChild(e);\n   li.appendChild(document.createTextNode(`: ${tiempo}`));\n\n   container.appendChild(ul);\n\n   return container;\n}\n\nexport default popupRuta;\n","export default function(n, total, lapso) {\n   const map = L.DomUtil.get(\"map\"),\n         progress = L.DomUtil.get(\"leaflet-progress\") || \n                    L.DomUtil.create(\"progress\", \"leaflet-message leaflet-control\", map);\n   progress.id = \"leaflet-progress\";\n   progress.setAttribute(\"value\", n/total);\n   if(n === total) setTimeout(() => L.DomUtil.remove(progress), 500);\n}\n","// extracted by mini-css-extract-plugin","// Issue #51\nfunction searchBar() {\n   // CodidoProvincial: Nombre del instituto\n   const label = (d) => `${String(d.id.cp).substring(0,2)}: ${d.id.nom}`;\n\n   const control = new L.Control.Search({\n      position: \"topright\",\n      textPlaceholder: \"Busque por nombre\",\n      textErr: \"No encontrado\",\n      initial: false,\n      // Así nos aseguramos que se ve la marca seleccionada.\n      zoom: this.cluster.options.disableClusteringAtZoom,\n      marker: false,\n      minLength: 3,\n      sourceData: (text, callback) => {\n         callback(this.cluster.getLayers().map(m => {\n            const data = m.getData();\n            return {\n               title: label(data),\n               loc: m.getLatLng()\n            }\n         }));\n\n         return { abort: function() {}}\n      },\n      filterData: (text, records)  => {\n         const ret = {},\n         pathData = this.Centro.prototype.options.mutable,\n         coincidentes = new Fuse(\n            this.cluster.getLayers(), {\n               keys: [pathData + \".id.nom\"],\n               minMatchCharLength: 2,\n            }).search(text);\n\n         for(const idx in coincidentes) {\n            const data = coincidentes[idx].getData(),\n                  title = label(data),\n                  centro = records[title];\n\n            if(!centro) continue;\n\n            ret[title] = centro;\n            // Encchufamos la marca del centro para tenerla\n            // disponible en el evento search:locationfound.\n            centro.layer = coincidentes[idx];\n         }\n\n         return ret;\n      }\n   });\n\n   control.on(\"search:locationfound\", e => {\n      this.seleccionado = e.layer;\n      control.collapse();\n   });\n\n   return control;\n}\n// Fin issue #51\n\nexport default searchBar;\n","import {getPath} from \"app/utils/misc.js\";\nimport svg from \"./images/localidad.svg\";\n\nconst converter = new L.utils.Converter([\"peticion\"])\n                             .define(\"peticion\");\n\nfunction updater(o) {\n   if(o.peticion === undefined) return;\n   const text = this.querySelector(\"text\"),\n         textInDefs = this.querySelector(\"defs\").querySelector(\"text\");\n\n   text.textContent = o.peticion;\n   if(o.peticion > 0) {\n      if(textInDefs) this.querySelector(\"defs\").parentNode.appendChild(text);\n      if(o.peticion > 99) {\n         text.setAttribute(\"y\", \"235\");\n         text.setAttribute(\"font-size\", \"180\");\n      }\n      else {\n         text.setAttribute(\"y\", \"265\");\n         text.setAttribute(\"font-size\", \"230\");\n      }\n   }\n   else if(!textInDefs) this.querySelector(\"defs\").appendChild(text);\n   \n   const color = o.peticion === 0?\"#0ae\":\"#d70\"\n   this.querySelector(\"path\").setAttribute(\"fill\", color);\n}\n\nexport default L.utils.createMutableIconClass(\"localidad\", {\n   iconSize: [26, 40],\n   iconAnchor: [13, 39.43],\n   url: getPath(svg),\n   converter: converter,\n   updater: updater\n});\n","module.exports = \"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDM2NSA1NjAiPg0KICAgPGRlZnM+DQogICAgICA8dGV4dCB4PSIxODIiIHk9IjI2NSIgc3Ryb2tlPSIjMDAwIiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iIzAwMCIgZm9udC1zaXplPSIyNDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiPjA8L3RleHQ+DQogICA8L2RlZnM+DQogICA8cGF0aCBmaWxsPSIjMGFlIiBkPSJNMTgyLjksNTUxLjdjMCwwLjEsMC4yLDAuMywwLjIsMC4zUzM1OC4zLDI4MywzNTguMywxOTQuNmMwLTEzMC4xLTg4LjgtMTg2LjctMTc1LjQtMTg2LjkNCiAgICAgIEM5Ni4zLDcuOSw3LjUsNjQuNSw3LjUsMTk0LjZjMCw4OC40LDE3NS4zLDM1Ny40LDE3NS4zLDM1Ny40UzE4Mi45LDU1MS43LDE4Mi45LDU1MS43eiIvPg0KPC9zdmc+DQo=\"","import icono from \"./icon.js\"\n\n// Issue #79, #83\n/**\n * Crea la capa con las localidades\n */\nfunction create() {\n\n   /**\n    * Capa para almacenar las localidades.\n    * @memberof MadAdjOfer.prototype\n    * @type {L.GeoJSON}\n    *\n    */\n   const localidades = L.geoJSON(undefined, {\n      pointToLayer: (f, p) => {\n         const localidad = new this.Localidad(p, {\n            icon: new Icono(),\n            title: f.properties.nom\n         });\n         localidad.on(\"dataset\", e => {\n            e.target.changeData({peticion: 0});\n            Object.defineProperty(e.target.getData(), \"codigo\", {\n               get: function() {\n                  return this.cod.toString().padStart(9, \"0\") + \"L\";\n               }\n            });\n         });\n         if(this.options.light) localidad.once(\"dataset\", e => {\n            e.target.on(\"click\", e => {\n               if(this.options.light && this.mode === \"solicitud\") {\n                  this.fire(\"requestclick\", {marker: e.target});\n               }\n            });\n         });\n         return localidad;\n      }\n   });\n\n   /**\n    * Marca para localidad\n    * @memberof MadAdjOfer.prototype\n    * @type {Marker}\n    */\n   this.Localidad = L.Marker.Mutable.extend({\n      statics: {\n         get: function(cod) {\n            if(typeof cod === \"string\" && cod.endsWith(\"L\")) cod = cod.slice(0, -1);\n            for(const loc of this.store) {\n               if(loc.getData().cod == cod) return loc;\n            }\n            return null;\n         }\n      },\n      options: {\n         mutable: \"feature.properties\",\n         filter: this.cluster,\n      }\n   });\n\n   // Filtro indiscriminado: sirve para ocultar de inicio las localidades.\n   this.Localidad.registerF(\"invisible\", {\n      attrs: [],\n      func: function(opts) {\n         return true;\n      }\n   });\n\n   \n   // Las localidades, por defecto, no se ven.\n   this.on(\"statusset\", e => {\n      if(!e.status) this.Localidad.filter(\"invisible\", {});\n   });\n\n   // Como el de centro: filtra las localidades solicitadas.\n   this.Localidad.registerF(\"solicitado\", {\n      attrs: \"peticion\",\n      func: function(opts) {\n         return !!(opts.inv ^ (this.getData().peticion > 0))\n      }\n   });\n\n   const Icono = icono;\n\n   if(!this.options.pathLoc) {\n      console.error(\"No pueden cargarse las localidades\");\n      return;\n   }\n\n\n   // Elimina los municipios de los que no se sabe el código\n   // y la declaración de la provincia de las propiedades\n   function limpiaDatos(data) {\n      data.features = data.features.filter(f => !!f.properties.cod);\n      data.features.forEach(f => delete f.properties.pro);\n   }\n\n\n   Icono.onready(() => {\n      L.utils.load({\n         url: this.options.pathLoc,\n         callback: xhr => {\n            const data = JSON.parse(xhr.responseText);\n            limpiaDatos(data);\n            localidades.addData(data);\n            this.cluster.addLayer(localidades);\n            this.Localidad.invoke(\"refresh\");  // Por alguna extraña razón, a veces se ven\n            this.fire(\"locloaded\");\n         },\n         failback: xhr => console.error(\"No pueden cargarse los datos de localidad\"),\n      });\n   });\n}\n// Fin issue #79, #83\n\nexport default create;\n","import {addDescriptor} from \"app/utils/misc.js\"\n\n// Issue #46\nfunction Geocode(ORS, opts) {\n   const defaults = {\n      \"boundary.country\": \"ES\"  // Restringimos las búsquedas a España.\n   }\n\n   this.url = ORS.URLBase + \"/geocode\";\n   this.ORS = ORS;\n   this.options = Object.assign({api_key: ORS.ors.key}, defaults);\n   this.setOptions(opts);\n\n   addDescriptor(this, \"value\", false, true);\n}\n\nGeocode.prototype.setOptions = function(opts) {\n   Object.assign(this.options, opts);\n}\n\n/**\n * Realiza la consulta de geocodificación de manera que obtiene\n * unas coordenadas si se introduce una dirección o una dirección\n * si se introducen unas coordenadas.\n *\n * @param {String, L.LatLng} data  Los datos de la consulta.\n *\n */\nGeocode.prototype.query = async function(data) {\n   return new Promise((resolve, reject) => {\n      if(this.value === null) {\n         resolve(null);\n         return;\n      }\n\n      this.value = null;\n      this.ORS.espera.push(\"geocode\");\n\n      if(this.ORS.ors.loading) this.ORS.ors.loading(\"geocodificacion\");\n\n      let furl, params;\n      if(typeof data === \"string\") { // Es una dirección.\n         furl = this.url + \"/search\";\n         params = Object.assign({text: data}, this.options);\n      }\n      else {  // Es una coordenada.\n         furl = this.url + \"/reverse\";\n         params = Object.assign({\"point.lon\": data.lng, \"point.lat\": data.lat}, this.options);\n      }\n\n      L.utils.load({\n         url: furl,\n         method: \"GET\",\n         params: params,\n         callback: xhr => {\n            if(this.ORS.ors.loading) this.ORS.ors.loading(\"geocode\");\n            const response = JSON.parse(xhr.responseText),\n                  parser = typeof data === \"string\"?obtenerCoordenadas:obtenerDireccion;\n            this.value = parser(response, data);\n            this.ORS.espera.remove(\"geocode\");\n            resolve(true);\n         },\n         failback: xhr => {\n            if(this.ORS.ors.loading) this.ORS.ors.loading(\"geocode\");\n            failback(xhr);\n            this.value = JSON.parse(xhr.responseText).error;\n            this.ORS.espera.remove(\"geocode\");\n            resolve(undefined);\n         }\n      });\n   });\n}\n\n// TODO:: La obtención de direcciones habría que estudiarla bien.\nfunction obtenerDireccion(data) {\n   return data.features.length === 0?\"Dirección desconocida\":data.features[0].properties.label;\n}\n\nfunction obtenerCoordenadas(data, search) {\n   if(data.features.length === 0) {\n      console.error(`Imposible localizar '${search}'`);\n      return null;\n   }\n\n   return data.features;\n}\n// Fin issue #46\n\nexport default Geocode;\n","import popupRuta from \"app/interface/popupruta.js\";\nimport loading from \"app/interface/loading.js\";\nimport Isocronas from \"./isochrones.js\";\nimport Geocode from \"./geocode.js\";\nimport Ruta from \"./route.js\";\n\nfunction ORS(adjofer) {\n   const defaults = {\n            chunkProgress: true,\n            rutaPopup: true\n         };\n\n   this.URLBase = \"https://api.openrouteservice.org\";\n\n   this.espera = [];\n   this.espera.remove = function(value) {\n      const idx = this.indexOf(value);\n      if(idx !== -1) {\n         this.splice(idx, 1)\n         return true;\n      }\n      return false;\n   }\n\n   this.adjofer = adjofer;\n\n   this.ors = Object.assign({}, defaults, adjofer.options.ors);\n   Object.assign(this.ors, {\n      chunkProgress: this.ors.chunkProgress && adjofer.progressBar,\n      loading: this.ors.loading || adjofer.options.loading && loading,\n      rutaPopup: this.ors.rutaPopup && popupRuta\n   });\n\n   this.isocronas = new Isocronas(this);\n   // Colocamos las isocronas por debajo de 400, para que siempre\n   // queden por debajo de otros polígonos y segmentos (como las rutas).\n   adjofer.map.createPane(\"isochronePane\").style.zIndex = 390;\n\n   this.ruta = new Ruta(this);\n   this.geocode = new Geocode(this);\n\n}\n\nexport default ORS;\n","import {addDescriptor, rgb2hex, HSLtoRGB} from \"app/utils/misc.js\";\nimport {mismoPunto, failback} from \"./utils.js\";\n\nfunction Isocronas(ORS, opts) {\n   const defaults = {\n      profile: \"driving-car\",\n      range_type: \"time\",\n      interval: 600,\n      range: 3600,\n      location_type: \"start\",\n      intersections: false,\n   }\n\n   // Para la interrupción del cálculo de las\n   // isocronas. cuando se demora mucho su cálculo.\n   this.progress = {\n      interval: 200,\n      delay: 50\n   }\n\n   /*\n   try {\n      turf\n   }\n   catch(e) {\n      throw new ReferenceError(\"No se encuentra cargado turf. ¿Ha olvidado cargar la librería en el HTML?\");\n   }\n   */\n\n   this.ORS = ORS;\n   this.url = ORS.URLBase + \"/v2/isochrones\";\n   this.options = Object.assign({}, defaults);\n   this.setOptions(opts);\n\n   this.layer = L.geoJSON(undefined, {\n      style: f => new Object({\n                     color: rgb2hex(HSLtoRGB(f.properties.ratio, .75, .30)),\n                     opacity: 0.6\n                  }),\n      onEachFeature: (f, l) => {\n         l.bindContextMenu(contextMenuArea.call(this, l, this.layer));\n      },\n      pane: \"isochronePane\"\n   });\n\n   addDescriptor(this, \"areas\", false, true);  //false: no hecha, null: en proceso.\n   // Resultado del último cálculo, por si se piden\n   // otra vez las isocronas definidas por el mismo origen.\n   addDescriptor(this, \"calc\", {origen: null, areas: null}, false);\n}\n\nIsocronas.prototype.setOptions = function(opts) {\n   Object.assign(this.options, opts);\n   if(!(this.options.range instanceof Array)) {\n      this.options.range = [this.options.range];\n   }\n   return this;\n}\n\n/**\n * Crea las isocronas, en principio tomando como referencia la marca de origen.\n * Es función asíncrona cuya promesa devuelve ``null`` si ya había otra petición\n * en curso; ``false``, si se recuperaron las últimas isocronas, ``true``, si\n * se generaron unas nuevas; e ``undefined`, si se produjo un error.\n *\n * @param {L.LatLng} point  Punto que se tomará como referencia\n * para el cálculo de las isocronas. Si no se proporciona, se\n * toma el origen de los viajes.\n */\nIsocronas.prototype.create = async function(point) {\n   point = point || this.ORS.adjofer.origen.getLatLng();\n\n   return new Promise((resolve, reject) => {\n      if(this.areas === null) {\n         resolve(null);\n         return;\n      }\n\n      this.ORS.espera.push(\"isocronas\");\n\n      // Si repetimos origen, entonces rescatamos las isocronas calculadas.\n      if(mismoPunto(point, this.calc.origen)) {\n         if(!this.areas) {  // Se llegaron a borrar.\n            redibujarAnillos.call(this);\n            this.layer.addTo(this.ORS.adjofer.map);\n            this.areas = this.calc.areas;\n         }\n         resolve(false);\n         return;\n      }\n      else {\n         if(this.areas) this.remove();\n         this.areas = this.calc.origen = this.calc.areas = null;\n      }\n\n      let params = Object.assign({locations: [[point.lng, point.lat]]},\n                                  this.options);\n\n      if(this.ORS.ors.loading) this.ORS.ors.loading(\"isocronas\");\n      L.utils.load({\n         url: this.url + \"/\" + params.profile,\n         headers: { Authorization: this.ORS.ors.key },\n         contentType: \"application/json; charset=UTF-8\",\n         params: params,\n         callback: xhr => {\n            crearIsocronas.call(this, xhr, point).then(() => {\n               this.ORS.espera.remove(\"isocronas\");\n               resolve(true);\n            });\n         },\n         failback: xhr => { \n            failback(xhr);\n            this.ORS.espera.remove(\"isocronas\");\n            resolve(undefined);\n         }\n      });\n   });\n}\n\n\nasync function crearIsocronas(xhr, point) {\n   if(this.ORS.ors.loading) this.ORS.ors.loading(\"isocronas\");\n\n   const started = (new Date()).getTime();\n   // Estos polígonos son completamente macizos, es decir,\n   // el referido a la isocrona de 30 minutos, contiene\n   // también las áreas de 10 y 20 minutos.\n   const data = JSON.parse(xhr.responseText);\n   this.layer.addTo(this.ORS.adjofer.map);\n\n   return new Promise(resolve => {\n      // La ejecución a intervalos se ha tomado del codigo de Leaflet.markercluster\n      let i=0;\n      const process = () => {\n         const start = (new Date()).getTime();\n         for(; i<data.features.length; i++) {\n            const lapso = (new Date()).getTime() - start;\n\n            // Al superar el intervalo, rompemos el bucle y\n            // liberamos la ejecución por un breve periodo.\n            if(this.ORS.ors.chunkProgress && lapso > this.progress.interval) break;\n\n            const anillo = i>0?turf.difference(data.features[i], data.features[i-1]):\n                           Object.assign({}, data.features[0]);\n\n            // turf hace que anillo y data.features[i] compartan properties,\n            // pero se necesita que sean objetos diferentes para que uno tenga\n            // la propiedad area y el otro no.\n            anillo.properties = Object.assign({}, data.features[i].properties, {\n               ratio:  1 - i/data.features.length,\n               area: data.features[i]  // Las área macizas sirven para filtrado.\n            });\n            data.features[i].properties.ratio = anillo.properties.ratio;\n\n            this.layer.addData(anillo);\n         }\n\n         if(this.ORS.ors.chunkProgress) {\n            this.ORS.ors.chunkProgress(i, data.features.length,\n                                       (new Date().getTime() - started));\n         }\n\n         if(i === data.features.length) {\n            this.calc.origen = point;\n            this.areas = this.calc.areas = this.layer.getLayers();\n            resolve();\n         }\n         else setTimeout(process, this.progress.delay);\n      }\n      process();\n   });\n}\n\n\n/**\n * Elimina las isocronas.\n */\nIsocronas.prototype.remove = function() {\n   if(!this.areas) return false;\n   this.layer.clearLayers();\n   this.layer.removeFrom(this.ORS.adjofer.map);\n   this.areas = false;\n   return this;\n}\n\n\nfunction contextMenuArea(area) {\n   // Los anillos tienen entre sus propiedades el área maciza,\n   // pero las áreas macizas, no tienen área alguna.\n   const es_anillo = !!area.feature.properties.area;\n\n   const items = [\n      {\n         text: \"Eliminar isocronas\",\n         callback: e => this.ORS.adjofer.setIsocronas(null),\n         index: 0,\n      }\n   ]\n\n   if(es_anillo) {\n      items.push({\n         text: `Filtrar centros alejados más de ${area.feature.properties.value/60} min`,\n         callback: e => {\n            const maciza = area.feature.properties.area;\n            let idx;\n            for(idx in this.areas) {\n               if(this.areas[idx] === area) break;\n            }\n\n            this.ORS.adjofer.Centro.filter(\"lejos\", {area: maciza, idx: Number(idx)});\n            this.ORS.adjofer.Centro.invoke(\"refresh\");\n            this.dibujarAreaMaciza(maciza);\n         },\n         index: 1,\n      })\n   }\n   else {\n      items.push({\n         text: `Mostrar centros alejados más de ${area.feature.properties.value/60} min`,\n         callback: e => {\n            this.ORS.adjofer.Centro.unfilter(\"lejos\");\n            this.ORS.adjofer.Centro.invoke(\"refresh\");\n            redibujarAnillos.call(this);\n         },\n         index: 1\n      });\n   }\n\n   items.push({separator: true, index: 2});\n\n   return {\n      contextmenu: true,\n      contextmenuInheritItems: true,\n      contextmenuItems: items\n   }\n}\n\nIsocronas.prototype.dibujarAreaMaciza = function(area) {\n   this.layer.clearLayers().addData(area);\n   const a = this.layer.getLayers()[0];\n   a.bindContextMenu(contextMenuArea.call(this, a));\n}\n\nfunction redibujarAnillos() {\n   this.layer.clearLayers();\n   for(const a of this.calc.areas) this.layer.addLayer(a);\n}\n\n\n/**\n * Devuelve las capas de las áreas que constityen las isocronas.\n */\nIsocronas.prototype.get = function(maciza) {\n   let areas = this.calc.areas;\n   if(maciza) areas = areas.map(a => a.feature.properties.area);\n   return areas;\n}\n\nexport default Isocronas;\n","import {addDescriptor} from \"app/utils/misc.js\";\nimport {mismoPunto} from \"./utils.js\";\n\nfunction Ruta(ORS, opts) {\n   const defaults = {\n      profile: \"driving-car\"\n   }\n\n   this.url = ORS.URLBase + \"/v2/directions\";\n   this.ORS = ORS;\n   this.options = Object.assign({api_key: ORS.ors.key}, defaults);\n   this.setOptions(opts);\n\n   this.layer = L.geoJSON(undefined, {\n      style: f => new Object({\n                     color: \"#77f\",\n                     weight: 5,\n                     opacity: 0.9\n                  }),\n      onEachFeature: (f, l) => {\n         if(ORS.ors.rutaPopup) {\n            l.bindPopup(ORS.ors.rutaPopup(this.calc.destino, f));\n         }\n      }\n   });\n\n   addDescriptor(this, \"value\", false, true); // value= {polilinea, destino}\n   addDescriptor(this, \"calc\", {origen: null,\n                                destino: null,\n                                layer: null}, true);\n}\n\nRuta.prototype.setOptions = function(opts) {\n   Object.assign(this.options, opts);\n}\n\nRuta.prototype.create = async function(destino) {\n   if(this.value) this.remove();\n\n   return new Promise((resolve, reject) => {\n      if(this.value === null) {\n         resolve(null);\n         return;\n      }\n\n      if(mismoPunto(this.ORS.adjofer.origen, this.calc.origen) &&\n         mismoPunto(destino, this.calc.destino)) {\n\n         dibujarRuta.call(this);\n         this.value = {\n            layer: this.calc.layer,\n            destino: this.calc.destino\n         }\n         resolve(false);\n         return;\n      }\n\n      this.ORS.espera.push(\"rutas\");\n\n      this.value = this.calc.destino = this.calc.layer = null;\n      this.calc.origen = this.ORS.adjofer.origen;\n\n      const origen = this.ORS.adjofer.origen.getLatLng(),\n            fin    = destino.getLatLng(),\n            params = Object.assign({\n                        start: origen.lng + \",\" + origen.lat,\n                        end: fin.lng + \",\" + fin.lat,\n                     }, this.options),\n            furl = this.url + \"/\" + params.profile;\n\n      delete params.profile;\n      \n      if(this.ORS.ors.loading) this.ORS.ors.loading(\"ruta\");\n      L.utils.load({\n         url: furl,\n         method: \"GET\",\n         params: params,\n         callback: xhr => { \n            crearRuta.call(this, xhr, destino);\n            this.ORS.espera.remove(\"rutas\");\n            resolve(true);\n         },\n         failback: xhr => {\n            failback(xhr);\n            this.ORS.espera.remove(\"rutas\");\n            resolve(undefined);\n         }\n      });\n   });\n}\n\nfunction crearRuta(xhr, destino) {\n   if(this.ORS.ors.loading) this.ORS.ors.loading(\"ruta\");\n\n   const data = JSON.parse(xhr.responseText);\n   this.calc.destino = destino;\n   this.calc.origen = this.ORS.adjofer.origen;\n   this.value = {destino: destino};\n\n   this.calc.layer = this.value.layer = dibujarRuta.call(this, data);\n}\n\nfunction dibujarRuta(ruta) {\n   let layer;\n\n   // Si no se proporciona ruta, es porque\n   // se reaprovecha la marca almacenada en calc.\n   if(ruta === undefined) {\n      layer = this.calc.layer;\n      ruta = layer.feature;\n      this.layer.addLayer(layer);\n   }\n   else {\n      this.layer.addData(ruta);\n      ruta = ruta.features[0];\n      layer = this.layer.getLayers()[0];\n   }\n\n   this.layer.addTo(this.ORS.adjofer.map);\n\n   const coords = ruta.geometry.coordinates,\n         point  = coords[Math.floor(.9*coords.length)];\n\n   if(this.ORS.ors.rutaPopup) layer.openPopup({lat: point[1], lng: point[0]});\n   return layer;\n}\n\nRuta.prototype.remove = function() {\n   if(!this.value) return false;\n\n   this.layer.clearLayers();\n   this.layer.removeFrom(this.ORS.adjofer.map);\n   this.value = false;\n   return this;\n}\n// Fin issue #47\n\nexport default Ruta;\n","function failback(xhr) {\n   const response = JSON.parse(xhr.responseText);\n   console.error(\"Error \" + response.error.code + \": \" + response.error.message);\n}\n\nfunction mismoPunto(x, y) {\n   if(x === null || y === null) return false;\n   if(x.getLatLng) x = x.getLatLng();\n   if(y.getLatLng) y = y.getLatLng();\n   return x.lat === y.lat && x.lng === y.lng;\n}\n\nexport {failback, mismoPunto}\n","// Issue #79\n// Módulo para gestionar las solicitudes de centro.\n\nimport {normalizeCodigo} from \"app/utils/misc.js\";\n\n/**\n * centros debe ser la propiedad donde se almacenan los centros\n * y localidades la propiedad donde se almacenan localidades,\n * Puede usarse la notación de punto.\n */\nfunction Solicitud(adjofer) {\n   Object.defineProperties(this, {\n      store: {\n         value: [],\n         writable: false,\n         enumerable: false,\n         configurable: false,\n      },\n      adjofer: {\n         value: adjofer,\n         writable: false,\n         enumerable: false,\n         configurable: false\n      },\n      BolicheIcono: {\n         value: adjofer.getIcon(\"boliche\"),\n         writable: false,\n         enumerable: true,\n         configurable: false\n      },\n      SolicitudIcono: {\n         value: adjofer.getIcon(\"solicitud\"),\n         writable: false,\n         enumerable: true,\n         configurable: false\n      }\n   });\n\n   // Define un filtro para eliminar centros seleccionados\n   adjofer.Centro.registerF(\"solicitado\", {\n      attrs: \"peticion\",\n      // opts= {inv: false}  // Si inv=true, elimina los no seleccionados.\n      func: function(opts) {\n         return !!(opts.inv ^ (this.getData().peticion > 0))\n      }\n   });\n\n   // Al cargar datos cambian las marcas de centro,\n   // pero queremos conservar la lista de peticiones,\n   // así que recostruimos \"store\" a partir de la lista\n   // de \"status\" y dejamos el código, si el centro no existe.\n   adjofer.on(\"dataloaded\", e => {\n      this.store.length = 0;\n      if(!e.target.status.list) return;\n      for(let i=0; i<e.target.status.list.length; i++) {\n         const cod = e.target.status.list[i];\n         if(cod instanceof L.Marker.Mutable) continue;\n\n         const tipo = cod.endsWith(\"L\")?\"Localidad\":\"Centro\",\n               entidad = e.target[tipo].get(cod);\n\n         if(entidad) {\n            this.store[i] = entidad;\n            entidad.changeData({peticion: i+1});\n            e.target.fire(\"requestset\", {marker: entidad, oldval: 0, newval: i+1});\n         }\n         else this.store[i] = cod;\n      }\n   });\n\n   adjofer.on(\"locloaded\", e => {\n      if(!e.target.status.list) return;\n      for(let i=0; i<e.target.status.list.length; i++) {\n         const cod = e.target.status.list[i];\n         if(cod instanceof L.Marker && cod.endsWith(\"C\")) continue;\n\n         const localidad = e.target.Localidad.get(cod);\n         if(localidad) {\n            this.store[i] = localidad;\n            localidad.changeData({peticion: i});\n         }\n         else this.store[i] = cod;\n      }\n   });\n}\n\nObject.defineProperties(Solicitud.prototype, {\n   centros: {\n      get: function() {\n         return this.adjofer.Centro.store;\n      },\n      enumerable: false,\n      configurable: false,\n   },\n   localidades: {\n      get: function() {\n         return this.adjofer.localidades.getLayers();\n      },\n      enumerable: false,\n      configurable: false,\n   },\n   list: {\n      get: function() {\n         return this.store.map(normalizeCodigo.bind(this));\n      },\n      enumerable: true,\n      configurable: false\n   }\n});\n\n\n// Obtiene la marca de un centro o una localidad a partir del código.\nfunction getMarker(centro) {\n   if(centro instanceof L.Marker) return centro;\n\n   centro = normalizeCodigo.call(this, centro);\n   if(!centro) return null;\n\n   const last = centro.charAt(centro.length-1);\n   return last === \"C\"?this.adjofer.Centro.get(centro):\n                       this.adjofer.Localidad.get(centro);\n}\n\n/**\n * Devuelve cuál es el centro que ocupa la petición N. null, si no\n * ocupa ninguna petición.\n */\nSolicitud.prototype.getCentro = function(position) {\n   return this.store[position - 1] || null;\n}\n\n/**\n * Devuelve qué petición ocupa el centro. 0, si no está pedido.\n */\nSolicitud.prototype.getPosition = function(centro) {\n   centro = getMarker.call(this, centro);\n   if(!centro) return 0;\n\n   for(let i=0; i<this.store.length; i++) {\n      if(this.store[i] === centro) return i+1;\n   }\n   return 0;\n}\n\n\n/**\n * Añade un centro al final de la lista de peticiones.\n * @param {L.Marker|Number|String} centro El centro a añadir.\n *\n * @returns {L.Marker} El propio centro si se añadió, o null\n * si no se hizo.\n */\nSolicitud.prototype.add = function(centro) {\n   centro = getMarker.call(this, centro);\n   if(!centro || this.getPosition(centro)) return null;\n\n   this.store.push(centro);\n   centro.changeData({peticion: this.store.length});\n   this.adjofer.fire(\"requestset\", {\n      marker: centro,\n      oldval: 0,\n      newval: this.store.length\n   });\n   this.adjofer.fire(\"requestchange\", {markers: [centro]});\n   return centro;\n}\n\n\nfunction actualiza(pos1, pos2) {\n   pos2 = pos2 || this.store.length;\n   for(let i=pos1 - 1; i < pos2; i++) {\n      const centro = this.store[i];\n\n      if(centro instanceof L.Marker.Mutable) {\n         const pos = centro.getData().peticion;\n         centro.changeData({peticion: i+1});\n         this.adjofer.fire(\"requestset\", {\n            marker: centro,\n            oldval: pos,\n            newval: i+1\n         });\n      }\n   }\n   return this.store.slice(pos1 - 1, pos2);\n}\n\n/**\n * Elimina uno o varios centros por su posición en la lista.\n * @param {Number} pos  Posición a partir de la cuál se eliminarán centros.\n * @param {Number} cuantos  Cuantos centros se quieren borrar. Si no\n * se especifican, se borran todos hasta el final.\n *\n * @returns Array  Un array con los centros afectados.\n */\nSolicitud.prototype.delete = function(pos, cuantos) {\n   if(pos<1 || pos>this.store.length) return [];\n\n   const restantes = this.store.length - pos + 1;\n   if(cuantos === undefined || cuantos > restantes) cuantos = restantes;\n   const eliminados = this.store.splice(pos-1, cuantos);\n   for(const centro of eliminados) {\n      if(!(centro instanceof L.Marker.Mutable)) continue;\n\n      const pos = centro.getData().peticion;\n      centro.changeData({peticion: 0});\n      this.adjofer.fire(\"requestset\", {\n         marker: centro,\n         oldval: pos,\n         newval: 0\n      });\n   }\n   const actualizados = actualiza.call(this, pos),\n         ret = eliminados.concat(actualizados);\n\n   this.adjofer.fire(\"requestchange\", {markers: ret});\n   return ret\n}\n\n/**\n * Elimina un centro de la lista de peticiones.\n * @param {L.Marker|Number|String} centro El centro a añadir.\n * \n * @returns Array  Un array con los centros afectados.\n */\nSolicitud.prototype.remove = function(centro) {\n   centro = getMarker.call(this, centro);\n   if(!centro) return [];\n   const pos = this.getPosition(centro),\n         ret = pos > 0?this.delete(pos, 1):[];\n\n   return ret;\n}\n\n\n/**\n * Inserta un centro en la posición indicada de la lista de peticiones.\n * @param {L.Marker|Number|String} centro El centro a añadir.\n * @param Number pos  La posición que debe ocupar en la lista.\n * \n * @returns Array  Un array con los centros afectados.\n */\nSolicitud.prototype.insert = function(centro, pos) {\n   centro = getMarker.call(this, centro);\n   if(!centro || this.getPosition(centro)) return [];\n\n   this.store.splice(pos - 1, 0, centro);\n   const ret = actualiza.call(this, pos);\n\n   this.adjofer.fire(\"requestchange\", {markers: ret});\n   return ret;\n}\n\n\n/**\n * Mueve de una posición a otra de la lista un número determinado de centros.\n */\nSolicitud.prototype.move = function(pos1, pos2, cuantos) {\n   pos2 = Math.max(pos2, 1);\n   pos2 = Math.min(pos2, this.store.length + 1);\n\n   const restantes = this.store.length - pos1 + 1;\n   if(cuantos === undefined || cuantos > restantes) cuantos = restantes;\n\n   const incr = pos2 - pos1,\n         tam = this.store.length;\n         \n\n   let ret;\n   if(incr < 0) { // El bloque de movidos sube en la lista.\n      const movidos = this.store.splice(pos1 - 1, cuantos);\n      Array.prototype.splice.apply(this.store, [pos2 - 1, 0].concat(movidos));\n      ret = actualiza.call(this, pos2, pos1 + cuantos - 1);\n   }\n   else {\n      const pos_f = pos2 - cuantos;\n      if(pos_f <= pos1) return [];\n\n      const movidos = this.store.splice(pos1 - 1, cuantos);\n      Array.prototype.splice.apply(this.store, [pos_f - 1, 0].concat(movidos));\n      ret = actualiza.call(this, pos1, pos2 - 1);\n   }\n\n   this.adjofer.fire(\"requestchange\", {markers: ret});\n   return ret;\n}\n// Fin issue #79\n\nexport default Solicitud;\n","import url from \"url\";\n\n// Issue #27\n/**\n * Crea una propiedad a la que se asocia un tipo de evento,\n * de manera que cuando se le da valor a la propiedad se lanzan\n * las acciones asociadas al evento *on*, y cuando se da valor null\n * se lanzan las acciones asociadas al evento *off*.\n *\n * @this El objeto al que se asocia el atributo.\n * @param {String} attr  El nombre del atributo que se creará.\n * @param {String} tipo  Nombre del tipo.\n * @param {*}  value     Valor inicial\n */\nfunction crearAttrEvent(attr, tipo, value=null) {\n   if(this.fire === undefined) throw new Error(\"El objeto no puede lanzar eventos\");\n\n   addDescriptor(this, \"_\" + attr, value, true);\n   Object.defineProperty(this, attr, {\n      get: function() { return this[\"_\" + attr]; },\n      set: function(value) {\n         const old = this[attr];\n         this[\"_\" + attr] = value;\n         this.fire(tipo, {oldval: old, newval: value});\n      },\n      configurable: false,\n      enumerable: true\n   });\n}\n// Fin issue #27;\n\n\n/**\n * Define una propiedad mediante un descriptor que no configurable ni enumerable.\n *\n * @param {Object} obj        Objeto en el que se define el descritor\n * @param {String}  name      Nombre de la propiedad\n * @param {Boolean} writable  Define si es o no escribible.\n */\nexport function addDescriptor(obj, name, value, writable) {\n   Object.defineProperty(obj, name, {\n      value: value,\n      writable: !!writable,\n      enumerable: false,\n      configurable: false\n   });\n}\n\n\n// Obtiene una gama de colores RGB distinguibles entre sí.\n// En principio, si se desea obtener 4 colores, habrá que pasar:\n// como ratio 1/4, 2/4, 3/4 y 4/4.\nfunction HSLtoRGB(h, s, l) {\n   s = s || .65;\n   l = l || .45;\n\n   var r, g, b;\n\n   if(s == 0){\n      r = g = b = l;\n   }\n   else {\n      function hue2rgb(p, q, t) {\n         if(t < 0) t += 1;\n         if(t > 1) t -= 1;\n         if(t < 1/6) return p + (q - p) * 6 * t;\n         if(t < 1/2) return q;\n         if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n         return p;\n      }\n\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1/3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1/3);\n   }\n\n   return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n\n// Convierte un array de tres enteros (RGB) en notación hexadecimal.\nfunction rgb2hex(rgb) {\n   return \"#\" + rgb.map(dec => (\"0\" + dec.toString(16)).slice(-2)).join(\"\");\n}\n\n\nfunction normalizeCodigo(centro) {\n   if(centro instanceof L.Marker.Mutable) {\n      return centro.getData().codigo;\n   }\n\n   centro = centro.toString();\n   let ret;\n\n   // Ya era un código normalizado.\n   const last = centro.charAt(centro.length-1);\n   switch(last) {\n      case \"C\":\n         ret = centro.padStart(9, \"0\");\n         break;\n\n      case \"L\":\n         ret = centro.padStart(10, \"0\");\n         break;\n\n      default:\n         switch(centro.length) {\n            case 7:  // Es con seguridad un centro\n               ret = (centro + \"C\").padStart(9, \"0\");\n               break;\n\n            case 9:  // Es con seguridad una localidad\n               ret = (centro + \"L\").padStart(10, \"0\");\n               break;\n\n            case 8:\n               // Es un centro a menos que empiece por 41,\n               // en cuyo caso puede ser una localidad de Almería\n               // o un centro de Sevilla.\n               if(!centro.startsWith(\"41\")) {\n                  ret = (centro + \"C\").padStart(9, \"0\");\n               }\n               else {\n                  // Si hay una localidad con ese código, resolvemos\n                  // que es la localidad y, si no, suponemos un centro.\n                  ret = this.adjofer.Localidad.get(centro);\n                  ret = ret?`0${centro}L`:`${centro}C`;\n               }\n               break;\n\n            default:\n               return null;\n         }\n   }\n   return ret;\n\n}\n\n\nconst scriptPath = document.currentScript;\n\n/**\n * Obtiene la ruta absoluta de un recurso cuya ruta relativa\n * se proporcionó respecto a la ruta absoluta de otro. \n *\n * @param {String} resource  Ruta relativa de otro recurso\n *    respecto al primero\n * @param {String} script    Ruta absoluta de un recurso. Si\n *    se proporciona como recurso un directorio, la ruta debe\n *    acabar con \"/\". Si no se especifica es la ruta de este\n *    mismo script.\n *\n * @returns {String} Ruta absoluta del segundo recurso.\n */\nfunction getPath(resource, script) {\n   // Es una dataURI.\n   if(resource.startsWith(\"data:\")) return resource;\n\n   script = script || scriptPath.src;\n   if(!script.endsWith(\"/\")) {\n      script = script.slice(0, script.lastIndexOf(\"/\") + 1);\n   }\n   return url.resolve(script, resource);\n}\n\n\nexport {crearAttrEvent, HSLtoRGB, rgb2hex, normalizeCodigo, getPath}\n","// Exporta las únicas librerías de turf necesarias.\n\nimport difference from \"@turf/difference/index.js\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon/index.js\";\n\nexport {difference, booleanPointInPolygon};\n","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet__;","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet_contextmenu__;","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet_search__;","module.exports = __WEBPACK_EXTERNAL_MODULE_leaflet_mutatismutandis__;"],"sourceRoot":""}